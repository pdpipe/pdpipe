<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>pdpipe.core API documentation</title>
<meta name="description" content="Defines pipelines for processing Pandas.DataFrame-based datasets â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdpipe.github.io/pdpipe/doc/pdpipe/core.html">
<link rel="icon" href="https://pdpipe.github.io/pdpipe/logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pdpipe.core</code></h1>
</header>
<section id="section-intro">
<p>Defines pipelines for processing Pandas.DataFrame-based datasets.</p>
<pre><code>&gt;&gt;&gt; import pdpipe as pdp
&gt;&gt;&gt; pipeline = pdp.ColDrop('Name') + pdp.Bin({'Speed': [0,5]})
&gt;&gt;&gt; pipeline = pdp.ColDrop('Name').Bin({'Speed': [0,5]}, drop=True)
</code></pre>
<h2 id="creating-pipeline-stages-that-operate-on-column-subsets">Creating pipeline stages that operate on column subsets</h2>
<p>Many pipeline stages in pdpipe operate on a subset of columns, allowing the
caller to deteremine this subset by either providing a fixed set of column
labels or by providing a callable that determines the column subset dynamically
from input dataframes. The <a title="pdpipe.cq" href="cq.html"><code>pdpipe.cq</code></a> module addresses a unique but important
use case of fittable column qualifier, which dynamically extract a column
subset on stage fit time, but keep it fixed for future transformations.</p>
<p>As a general rule, every pipeline stage in pdpipe that supports the <code>columns</code>
parameter should inherently support fittable column qualifier, and generally
the correct interpretation of both single and multiple labels as arguments. To
unify the implementation of such functionality, and ease of creation of new
pipeline stages, such columns shoul be created by extending the
ColumnsBasedPipelineStage base class, found in this module (<a title="pdpipe.core" href="#pdpipe.core"><code>pdpipe.core</code></a>).</p>
<p>The main interface of sub-classes of this base class with it is through the
<code>columns</code>, <code>exclude_columns</code> and <code>none_columns</code> constructor arguments, and the
"private" <code>_get_columns(df, fit)</code> method:</p>
<pre><code>* Any extending subclass should accept the `columns` constructor parameter
  and forward it, without transforming it, to the constructor of
  ColumnsBasedPipelineStage. E.g.
  `super().__init__(columns=columns, **kwargs)`. See the implementation of
  any such extending class for a more complete example.

* Extending subclasses can decide if they want to expose the
  `exclude_columns` parameter or not. Note that most of its functionality
  can anyway be gained by providing the `columns` parameter with a column
  qualifier object that is a difference between two column qualifiers; e.g.
  `columns=cq.OfDtype(np.number) - cq.OfDtype(np.int64)` is equivalent to
  providing `columns=cq.OfDtype(np.number),
  exclude_columns=cq.OfDtype(np.int64)`. However, exposing the
  `exclude_columns` parameter can allow for specific unique behaviours; for
  example, if the `none_columns` parametet - which configures the behavior
  when `columns` is provided with `None` - is set with
  a `cq.OfDtypes('category')` column qualifier, which means that all
  categorical columns are selected when `columns=None`, then exposing
  `exclude_columns` allows easy specification of the "all categorical
  columns except X" by just giving a column qualifier capturing X to
  `exclude_columns`, instead of having to reconstruct the default column
  qualifier by hand and substract from it the one representing X.

* When wishing to get the subset of columns to operate on, in
  `fit_transform` or `transform` time, it is attained by calling
  `self._get_columns(df, fit=True)` (or with `fit=False` if just
  transforming), providing it the input dataframe.

* Additionally, to get a description and application message with a nice
  string representation of the list of columns to operate on, the
  `desc_temp` constructor parameter of ColumnsBasedPipelineStage can be
  provided with a format string with a place holder where the column list
  should go. E.g. `"Drop columns {}"` for the DropCol pipeline stage.
</code></pre>
<p>There are two correct ways to extend it, depending on whether the pipeline
stage you're creating is inherently fittable or not:</p>
<pre><code>1. If the stage is NOT inherently fittable, then the ability to accept
   fittable column qualifier objects makes it so. However, to enable
   extending subclasses to implement their transformation using a single
   method, they can simply implement the abstract method
   `_transformation(self, df, verbose, fit)`. It should treat the `df` and
   `verbose` parameters normally, but forward the `fit` parameter to the
   `_get_columns` method when calling it. This is enough to get a pipeline
   stage with the desired behavior, with the super-class handling all the
   fit/transform functionality.

2. If the stage IS inherently fittable, then do not use the
   `_transformation` abstract method (it has to be implemented, so just
   have it raise a NotImplementedError). Instead, simply override the
   `_fit_transform` and `_transform` method of ColumnsBasedPipelineStage,
   calling the `fit` parameter of the `_get_columns` method with the
   correct arguement: `True` when fit-transforming and `False` when
   transforming.
</code></pre>
<p>Again, taking a look at the VERY concise implementation of simple columns-based
stages, like ColDrop or ValDrop, will probably make things clearer, and you can
use those implementations as a template for yours.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L0-L807" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Defines pipelines for processing Pandas.DataFrame-based datasets.

&gt;&gt;&gt; import pdpipe as pdp
&gt;&gt;&gt; pipeline = pdp.ColDrop(&#39;Name&#39;) + pdp.Bin({&#39;Speed&#39;: [0,5]})
&gt;&gt;&gt; pipeline = pdp.ColDrop(&#39;Name&#39;).Bin({&#39;Speed&#39;: [0,5]}, drop=True)

## Creating pipeline stages that operate on column subsets

Many pipeline stages in pdpipe operate on a subset of columns, allowing the
caller to deteremine this subset by either providing a fixed set of column
labels or by providing a callable that determines the column subset dynamically
from input dataframes. The `pdpipe.cq` module addresses a unique but important
use case of fittable column qualifier, which dynamically extract a column
subset on stage fit time, but keep it fixed for future transformations.

As a general rule, every pipeline stage in pdpipe that supports the `columns`
parameter should inherently support fittable column qualifier, and generally
the correct interpretation of both single and multiple labels as arguments. To
unify the implementation of such functionality, and ease of creation of new
pipeline stages, such columns shoul be created by extending the
ColumnsBasedPipelineStage base class, found in this module (`pdpipe.core`).

The main interface of sub-classes of this base class with it is through the
`columns`, `exclude_columns` and `none_columns` constructor arguments, and the
&#34;private&#34; `_get_columns(df, fit)` method:

    * Any extending subclass should accept the `columns` constructor parameter
      and forward it, without transforming it, to the constructor of
      ColumnsBasedPipelineStage. E.g.
      `super().__init__(columns=columns, **kwargs)`. See the implementation of
      any such extending class for a more complete example.

    * Extending subclasses can decide if they want to expose the
      `exclude_columns` parameter or not. Note that most of its functionality
      can anyway be gained by providing the `columns` parameter with a column
      qualifier object that is a difference between two column qualifiers; e.g.
      `columns=cq.OfDtype(np.number) - cq.OfDtype(np.int64)` is equivalent to
      providing `columns=cq.OfDtype(np.number),
      exclude_columns=cq.OfDtype(np.int64)`. However, exposing the
      `exclude_columns` parameter can allow for specific unique behaviours; for
      example, if the `none_columns` parametet - which configures the behavior
      when `columns` is provided with `None` - is set with
      a `cq.OfDtypes(&#39;category&#39;)` column qualifier, which means that all
      categorical columns are selected when `columns=None`, then exposing
      `exclude_columns` allows easy specification of the &#34;all categorical
      columns except X&#34; by just giving a column qualifier capturing X to
      `exclude_columns`, instead of having to reconstruct the default column
      qualifier by hand and substract from it the one representing X.

    * When wishing to get the subset of columns to operate on, in
      `fit_transform` or `transform` time, it is attained by calling
      `self._get_columns(df, fit=True)` (or with `fit=False` if just
      transforming), providing it the input dataframe.

    * Additionally, to get a description and application message with a nice
      string representation of the list of columns to operate on, the
      `desc_temp` constructor parameter of ColumnsBasedPipelineStage can be
      provided with a format string with a place holder where the column list
      should go. E.g. `&#34;Drop columns {}&#34;` for the DropCol pipeline stage.

There are two correct ways to extend it, depending on whether the pipeline
stage you&#39;re creating is inherently fittable or not:

    1. If the stage is NOT inherently fittable, then the ability to accept
       fittable column qualifier objects makes it so. However, to enable
       extending subclasses to implement their transformation using a single
       method, they can simply implement the abstract method
       `_transformation(self, df, verbose, fit)`. It should treat the `df` and
       `verbose` parameters normally, but forward the `fit` parameter to the
       `_get_columns` method when calling it. This is enough to get a pipeline
       stage with the desired behavior, with the super-class handling all the
       fit/transform functionality.

    2. If the stage IS inherently fittable, then do not use the
       `_transformation` abstract method (it has to be implemented, so just
       have it raise a NotImplementedError). Instead, simply override the
       `_fit_transform` and `_transform` method of ColumnsBasedPipelineStage,
       calling the `fit` parameter of the `_get_columns` method with the
       correct arguement: `True` when fit-transforming and `False` when
       transforming.

Again, taking a look at the VERY concise implementation of simple columns-based
stages, like ColDrop or ValDrop, will probably make things clearer, and you can
use those implementations as a template for yours.
&#34;&#34;&#34;

import sys
import inspect
import abc
import collections
import textwrap

from .cq import is_fittable_column_qualifier, AllColumns

from .exceptions import (
    FailedPreconditionError,
    UnfittedPipelineStageError,
)


# === loading stage attributes ===

def __get_append_stage_attr_doc(class_obj):
    doc = class_obj.__doc__
    first_line = doc[0:doc.find(&#39;.&#39;) + 1]
    if &#34;An&#34; in first_line:
        new_first_line = first_line.replace(&#34;An&#34;, &#34;Creates and adds an&#34;, 1)
    else:
        new_first_line = first_line.replace(&#34;A&#34;, &#34;Creates and adds a&#34;, 1)
    new_first_line = new_first_line[0:-1] + (
        &#34; to this pipeline stage.&#34;)
    return doc.replace(first_line, new_first_line, 1)


def __load_stage_attribute__(class_obj):

    def _append_stage_func(self, *args, **kwds):
        # self is always a PdPipelineStage
        return self + class_obj(*args, **kwds)
    _append_stage_func.__doc__ = __get_append_stage_attr_doc(class_obj)
    _append_stage_func.__name__ = class_obj.__name__  # .lower()
    _append_stage_func.__signature__ = inspect.signature(class_obj.__init__)
    setattr(PdPipelineStage, class_obj.__name__, _append_stage_func)

    # unbound_method = types.MethodType(_append_stage_func, class_obj)
    # setattr(class_obj, class_obj.__name__, unbound_method)


def __load_stage_attributes_from_module__(module_name):
    module_obj = sys.modules[module_name]
    for name, obj in inspect.getmembers(module_obj):
        if inspect.isclass(obj) and obj.__module__ == module_name:
            class_obj = getattr(module_obj, name)
            if issubclass(class_obj, PdPipelineStage) and (
                    class_obj.__name__ != &#39;PdPipelineStage&#39;):
                __load_stage_attribute__(class_obj)


# === basic classes ===


class PdPipelineStage(abc.ABC):
    &#34;&#34;&#34;A stage of a pandas DataFrame-processing pipeline.

    Parameters
    ----------
    exraise : bool, default True
        If true, a pdpipe.FailedPreconditionError is raised when this
        stage is applied to a dataframe for which the precondition does
        not hold. Otherwise the stage is skipped.
    exmsg : str, default None
        The message of the exception that is raised on a failed
        precondition if exraise is set to True. A default message is used
        if None is given.
    desc : str, default None
        A short description of this stage, used as its string representation.
        A default description is used if None is given.
    prec : callable, default None
        This can be assigned a callable that returns boolean values for input
        dataframes, which will be used to determine whether input dataframes
        satisfy the preconditions for this pipeline stage (see the `exraise`
        parameter for the behaviour of failed preconditions). See pdp.cond for
        more information on specialised Condition objects.
    skip : callable, default None
        This can be assigned a callable that returns boolean values for input
        dataframes, which will be used to determine whether this stage should
        be skipped for input dataframes. See pdp.cond for more information on
        specialised Condition objects.
    &#34;&#34;&#34;

    _DEF_EXC_MSG = &#39;Precondition failed in stage {}!&#39;
    _DEF_DESCRIPTION = &#39;A pipeline stage.&#39;
    _INIT_KWARGS = [&#39;exraise&#39;, &#39;exmsg&#39;, &#39;desc&#39;]

    def __init__(self, exraise=True, exmsg=None, desc=None, prec=None,
                 skip=None):
        if desc is None:
            desc = PdPipelineStage._DEF_DESCRIPTION
        if exmsg is None:
            exmsg = PdPipelineStage._DEF_EXC_MSG.format(desc)
        self._exraise = exraise
        self._exmsg = exmsg
        self._desc = desc
        self._prec_arg = prec
        self._skip = skip
        self._appmsg = &#39;{}..&#39;.format(desc)
        self.is_fitted = False

    @classmethod
    def _init_kwargs(cls):
        return cls._INIT_KWARGS

    @abc.abstractmethod
    def _prec(self, df):  # pylint: disable=R0201,W0613
        &#34;&#34;&#34;Returns True if this stage can be applied to the given dataframe.&#34;&#34;&#34;
        raise NotImplementedError

    def _compound_prec(self, df):
        if self._prec_arg:
            return self._prec_arg(df)
        return self._prec(df)

    def _fit_transform(self, df, verbose):
        &#34;&#34;&#34;Fits this stage and transforms the input dataframe.&#34;&#34;&#34;
        return self._transform(df, verbose)

    def _is_fittable(self):
        if self.__class__._fit_transform == PdPipelineStage._fit_transform:
            return False
        return True

    @abc.abstractmethod
    def _transform(self, df, verbose):
        &#34;&#34;&#34;Transforms the given dataframe without fitting this stage.&#34;&#34;&#34;
        raise NotImplementedError(&#34;_transform method not implemented!&#34;)

    def apply(self, df, exraise=None, verbose=False):
        &#34;&#34;&#34;Applies this pipeline stage to the given dataframe.

        If the stage is not fitted fit_transform is called. Otherwise,
        transform is called.

        Parameters
        ----------
        df : pandas.DataFrame
            The dataframe to which this pipeline stage will be applied.
        exraise : bool, default None
            Determines behaviour if the precondition of this stage is not
            fulfilled by the given dataframe: If True,
            a pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If None, the default behaviour of this stage is used, as
            determined by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._skip and self._skip(df):
            return df
        if self._compound_prec(df=df):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            if self.is_fitted:
                return self._transform(df, verbose=verbose)
            return self._fit_transform(df, verbose=verbose)
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return df

    __call__ = apply

    def fit_transform(self, X, y=None, exraise=None, verbose=False):
        &#34;&#34;&#34;Fits this stage and transforms the given dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to transform and fit this pipeline stage by.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of this stage is not
            fulfilled by the given dataframe: If True,
            a pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If None, the default behaviour of this stage is used, as
            determined by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._prec(X):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            return self._fit_transform(X, verbose=verbose)
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return X

    def fit(self, X, y=None, exraise=None, verbose=False):
        &#34;&#34;&#34;Fits this stage without transforming the given dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to be transformed.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of this stage is not
            fulfilled by the given dataframe: If True,
            a pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If None, the default behaviour of this stage is used, as
            determined by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._prec(X):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            self._fit_transform(X, verbose=verbose)
            return X
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return X

    def transform(self, X, y=None, exraise=None, verbose=False):
        &#34;&#34;&#34;Transforms the given dataframe without fitting this stage.

        If this stage is fittable but is not fitter, an
        UnfittedPipelineStageError is raised.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to be transformed.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of this stage is not
            fulfilled by the given dataframe: If True,
            a pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If None, the default behaviour of this stage is used, as
            determined by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._prec(X):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            if self._is_fittable():
                if self.is_fitted:
                    return self._transform(X, verbose=verbose)
                raise UnfittedPipelineStageError(
                    &#34;transform of an unfitted pipeline stage was called!&#34;)
            return self._transform(X, verbose=verbose)
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return X

    def __add__(self, other):
        if isinstance(other, PdPipeline):
            return PdPipeline([self, *other._stages])
        if isinstance(other, PdPipelineStage):
            return PdPipeline([self, other])
        return NotImplemented

    def __str__(self):
        return &#34;PdPipelineStage: {}&#34;.format(self._desc)

    def __repr__(self):
        return self.__str__()

    def description(self):
        &#34;&#34;&#34;Returns the description of this pipeline stage&#34;&#34;&#34;
        return self._desc


class ColumnsBasedPipelineStage(PdPipelineStage):
    &#34;&#34;&#34;A pipeline stage that operates on a subset of dataframe columns.

    Parameters
    ---------
    columns : object, iterable or callable
        The label, or an iterable of labels, of columns to use. Alternatively,
        this parameter can be assigned a callable returning an iterable of
        labels from an input pandas.DataFrame. See pdpipe.cq.
    exclude_columns : object, iterable or callable, optional
        The label, or an iterable of labels, of columns to exclude, given the
        `columns` parameter. Alternatively, this parameter can be assigned a
        callable returning a labels iterable from an input pandas.DataFrame.
        See pdpipe.cq. Optional. By default no columns are excluded.
    desc_temp : str, optional
        If given, assumed to be a format string, and every appearance of {} in
        it is replaced with an appropriate string representation of the columns
        parameter, and is used as the pipeline description. Ignored if `desc`
        is provided.
    none_columns : iterable, callable or str, default &#39;error&#39;
        Determines how None values supplied to the &#39;columns&#39; parameter should
        be handled. If set to &#39;error&#39;, the default, a ValueError is raised if
        None is encountered. If set to &#39;all&#39;, it is interpreted to mean all
        columns of input dataframes should be operated on. If an iterable is
        provided it is interpreted as the default list of columns to operate on
        when `columns=None`. If a callable is provided, it is interpreted as
        the default column qualifier that determines input columns when
        `columns=None`.
    **kwargs
        Additionally supports all constructor parameters of PdPipelineStage.
    &#34;&#34;&#34;

    @staticmethod
    def _interpret_columns_param(columns, none_error=False, none_columns=None):
        &#34;&#34;&#34;Interprets the value provided to the columns parameter and returns
        a list version of it - if needed - a string representation of it.
        &#34;&#34;&#34;
        if columns is None:
            if none_error:
                raise ValueError((
                    &#39;None is not a valid argument for the columns parameter of&#39;
                    &#39; this pipeline stage.&#39;))
            return ColumnsBasedPipelineStage._interpret_columns_param(
                columns=none_columns)
        if isinstance(columns, str):
            # always check str first, because it has __iter__
            return [columns], columns
        if callable(columns):
            return columns, columns.__doc__ or &#39;&#39;
        # if it was a single string it was already made a list, and it&#39;s not a
        # callable, so it&#39;s either an iterable of labels... or
        if hasattr(columns, &#39;__iter__&#39;):
            return columns, &#39;, &#39;.join(str(elem) for elem in columns)
        # a single non-string label.
        return [columns], str(columns)

    def __init__(
            self, columns, exclude_columns=None, desc_temp=None,
            none_columns=&#39;error&#39;, **kwargs):
        self._exclude_columns = exclude_columns
        if exclude_columns:
            self._exclude_columns = self._interpret_columns_param(
                exclude_columns)
        self._none_error = False
        self._none_cols = None
        # handle none_columns
        if isinstance(none_columns, str):
            if none_columns == &#39;error&#39;:
                self._none_error = True
            elif none_columns == &#39;all&#39;:
                self._none_cols = AllColumns()
            else:
                raise ValueError((
                    &#34;&#39;error&#39; and &#39;all&#39; are the only valid string arguments&#34;
                    &#34; to the none_columns constructor parameter!&#34;))
        elif hasattr(none_columns, &#39;__iter__&#39;):
            self._none_cols = none_columns
        elif callable(none_columns):
            self._none_cols = none_columns
        else:
            raise ValueError((
                &#34;Valid arguments to the none_columns constructor parameter&#34;
                &#34; are &#39;error&#39;, &#39;all&#39;, an iterable of labels or a callable!&#34;
            ))
        # done handling none_columns
        self._col_arg, self._col_str = self._interpret_columns_param(
            columns, self._none_error, none_columns=self._none_cols)
        if (kwargs.get(&#39;desc&#39;) is None) and desc_temp:
            kwargs[&#39;desc&#39;] = desc_temp.format(self._col_str)
        if kwargs.get(&#39;exmsg&#39;) is None:
            kwargs[&#39;exmsg&#39;] = (
                &#39;Pipeline stage failed because not all columns {} &#39;
                &#39;were found in the input dataframe.&#39;
            ).format(self._col_str)
        super().__init__(**kwargs)

    def _is_fittable(self):
        return is_fittable_column_qualifier(self._col_arg)

    @staticmethod
    def __get_cols_by_arg(col_arg, df, fit=False):
        try:
            if fit:
                # try to treat col_arg as a fittable column qualifier
                return col_arg.fit_transform(df)
            # else, no need to fit, so try to treat _col_arg as a callable
            return col_arg(df)
        except AttributeError:
            # got here cause col_arg has no fit_transform method...
            try:
                # so try and treat it as a callable again
                return col_arg(df)
            except TypeError:
                # calling col_arg 2 lines above failed; its a list of labels
                return col_arg
        except TypeError:
            # calling _col_arg 10 lines above failed; its a list of labels
            return col_arg

    def _get_columns(self, df, fit=False):
        cols = ColumnsBasedPipelineStage.__get_cols_by_arg(
            self._col_arg, df, fit=fit)
        if self._exclude_columns:
            exc_cols = ColumnsBasedPipelineStage.__get_cols_by_arg(
                self._exclude_columns, df, fit=fit)
            return [x for x in cols if x not in exc_cols]
        return cols

    def _prec(self, df):
        return set(self._get_columns(df=df)).issubset(df.columns)

    @abc.abstractmethod
    def _transformation(self, df, verbose, fit):
        raise NotImplementedError((
            &#34;Classes extending ColumnsBasedPipelineStage must implement the &#34;
            &#34;_transformation method!&#34;))

    def _fit_transform(self, df, verbose):
        self.is_fitted = True
        return self._transformation(df, verbose, fit=True)

    def _transform(self, df, verbose):
        return self._transformation(df, verbose, fit=False)


def _always_true(x):
    return True


class AdHocStage(PdPipelineStage):
    &#34;&#34;&#34;An ad-hoc stage of a pandas DataFrame-processing pipeline.

    Parameters
    ----------
    transform : callable
        The transformation this stage applies to dataframes.
    prec : callable, default None
        A callable that returns a boolean value. Represent a a precondition
        used to determine whether this stage can be applied to a given
        dataframe. If None is given, set to a function always returning True.
    &#34;&#34;&#34;

    def __init__(self, transform, prec=None, **kwargs):
        if prec is None:
            prec = _always_true
        self._adhoc_transform = transform
        self._adhoc_prec = prec
        super().__init__(**kwargs)

    def _prec(self, df):
        return self._adhoc_prec(df)

    def _transform(self, df, verbose):
        try:
            return self._adhoc_transform(df, verbose=verbose)
        except TypeError:
            return self._adhoc_transform(df)


class PdPipeline(PdPipelineStage, collections.abc.Sequence):
    &#34;&#34;&#34;A pipeline for processing pandas DataFrame objects.

    transformer_getter is usefull to avoid applying pipeline stages that are
    aimed to filter out items in a big dataset to create a training set for a
    machine learning model, for example, but should not be applied on future
    individual items to be transformed by the fitted pipeline.

    Parameters
    ----------
    stages : list
        A list of PdPipelineStage objects making up this pipeline.
    transform_getter : callable, optional
        A callable that can be applied to the fitted pipeline to produce a
        sub-pipeline of it which should be used to transform dataframes after
        the pipeline has been fitted. If not given, the fitted pipeline is used
        entirely.
    &#34;&#34;&#34;

    _DEF_EXC_MSG = &#39;Pipeline precondition failed!&#39;

    def __init__(self, stages, transformer_getter=None, **kwargs):
        self._stages = stages
        self._trans_getter = transformer_getter
        self.is_fitted = False
        super_kwargs = {
            &#39;exraise&#39;: False,
            &#39;exmsg&#39;: PdPipeline._DEF_EXC_MSG,
        }
        super_kwargs.update(**kwargs)
        super().__init__(**super_kwargs)

    # implementing a collections.abc.Sequence abstract method
    def __getitem__(self, index):
        if isinstance(index, slice):
            return PdPipeline(self._stages[index])
        return self._stages[index]

    # implementing a collections.abc.Sequence abstract method
    def __len__(self):
        return len(self._stages)

    def _prec(self, df):
        # PdPipeline overrides apply in a way which makes this moot
        raise NotImplementedError

    def _transform(self, df, verbose):
        # PdPipeline overrides apply in a way which makes this moot
        raise NotImplementedError

    def apply(self, df, exraise=None, verbose=False):
        if self.is_fitted:
            return self.transform(X=df, exraise=exraise, verbose=verbose)
        return self.fit_transform(X=df, exraise=exraise, verbose=verbose)

    def fit_transform(self, X, y=None, exraise=None, verbose=None):
        &#34;&#34;&#34;Fits this pipeline and transforms the input dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to transform and fit this pipeline by.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of composing stages is not
            fulfilled by the input dataframe: If True, a
            pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If not given, or set to None, the default behaviour of
            each stage is used, as determined by its &#39;exraise&#39; constructor
            parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            of each stage is checked but before its application. Otherwise, no
            messages are printed.

        Returns
        -------
        pandas.DataFrame
            The resulting dacaframe.
        &#34;&#34;&#34;
        inter_x = X
        for stage in self._stages:
            inter_x = stage.fit_transform(
                X=inter_x,
                y=None,
                exraise=exraise,
                verbose=verbose,
            )
        self.is_fitted = True
        return inter_x

    def fit(self, X, y=None, exraise=None, verbose=None):
        &#34;&#34;&#34;Fits this pipeline without transforming the input dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to fit this pipeline by.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of composing stages is not
            fulfilled by the input dataframe: If True, a
            pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If not given, or set to None, the default behaviour of
            each stage is used, as determined by its &#39;exraise&#39; constructor
            parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            of each stage is checked but before its application. Otherwise, no
            messages are printed.

        Returns
        -------
        pandas.DataFrame
            The input dataframe, unchanged.
        &#34;&#34;&#34;
        self.fit_transform(
            X=X,
            y=None,
            exraise=exraise,
            verbose=verbose,
        )
        return X

    def transform(self, X, y=None, exraise=None, verbose=None):
        &#34;&#34;&#34;Transforms the given dataframe without fitting this pipeline.

        If any stage in this pipeline is fittable but is not fitted, an
        UnfittedPipelineStageError is raised before transformation starts.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to transform.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of composing stages is not
            fulfilled by the input dataframe: If True, a
            pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If not given, or set to None, the default behaviour of
            each stage is used, as determined by its &#39;exraise&#39; constructor
            parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            of each stage is checked but before its application. Otherwise, no
            messages are printed.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        for stage in self._stages:
            if stage._is_fittable() and not stage.is_fitted:
                raise UnfittedPipelineStageError((
                    &#34;PipelineStage {} in pipeline is fittable but&#34;
                    &#34; unfitted!&#34;).format(stage))
        inter_df = X
        for stage in self._stages:
            inter_df = stage.transform(
                X=inter_df,
                y=None,
                exraise=exraise,
                verbose=verbose,
            )
        return inter_df

    __call__ = apply

    def __add__(self, other):
        if isinstance(other, PdPipeline):
            return PdPipeline([*self._stages, *other._stages])
        if isinstance(other, PdPipelineStage):
            return PdPipeline([*self._stages, other])
        return NotImplemented

    def __str__(self):
        res = &#34;A pdpipe pipeline:\n&#34;
        res += &#39;[ 0]  &#39; + &#34;\n      &#34;.join(
            textwrap.wrap(self._stages[0].description())) + &#39;\n&#39;
        for i, stage in enumerate(self._stages[1:]):
            res += &#39;[{:&gt;2}]  &#39;.format(i + 1) + &#34;\n      &#34;.join(
                textwrap.wrap(stage.description())) + &#39;\n&#39;
        return res

    def get_transformer(self):
        &#34;&#34;&#34;Return the transformer induced by this fitted pipeline.

           This transformer is a `pdpipe` pipeline that transforms input data
           in a way corresponding to this pipline after it has been fitted. By
           default this is the pipeline itself, but the `transform_getter`
           constructor parameter can be used to return a sub-pipeline of the
           fitted pipeline instead, for cases where some stages should only be
           applied when fitting this pipeline to data.

        Returns
        -------
        pdpipe.PdPipeline
            The corresponding transformer pipeline induced by this pipeline.
        &#34;&#34;&#34;
        try:
            return self._trans_getter(self)
        except TypeError:  # pragma: no cover
            return self

    # def drop(self, index):
    #     &#34;&#34;&#34;Returns this pipeline with the stage of the given index removed.

    #     Arguments
    #     ---------
    #     index


def make_pdpipeline(*stages):
    &#34;&#34;&#34;Constructs a PdPipeline from the given pipeline stages.

    Parameters
    ----------
    *stages : pdpipe.PipelineStage objects
       PdPipeline stages given as positional arguments.

    Returns
    -------
    p : pdpipe.PdPipeline
        The resulting pipeline.

    Examples
    --------
    import pdpipe as pdp
    make_pdpipeline(pdp.ColDrop(&#39;a&#39;), pdp.Bin(&#39;speed&#39;))
    &#34;&#34;&#34;
    return PdPipeline(stages=stages)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pdpipe.core.make_pdpipeline"><code class="name flex">
<span>def <span class="ident">make_pdpipeline</span></span>(<span>*stages)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs a PdPipeline from the given pipeline stages.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*stages</code></strong> :&ensp;<code>pdpipe.PipelineStage</code> <code>objects</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>PdPipeline stages given as positional arguments.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>pdpipe.PdPipeline</code></dt>
<dd>The resulting pipeline.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>import pdpipe as pdp
make_pdpipeline(pdp.ColDrop('a'), pdp.Bin('speed'))</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L790-L808" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def make_pdpipeline(*stages):
    &#34;&#34;&#34;Constructs a PdPipeline from the given pipeline stages.

    Parameters
    ----------
    *stages : pdpipe.PipelineStage objects
       PdPipeline stages given as positional arguments.

    Returns
    -------
    p : pdpipe.PdPipeline
        The resulting pipeline.

    Examples
    --------
    import pdpipe as pdp
    make_pdpipeline(pdp.ColDrop(&#39;a&#39;), pdp.Bin(&#39;speed&#39;))
    &#34;&#34;&#34;
    return PdPipeline(stages=stages)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pdpipe.core.AdHocStage"><code class="flex name class">
<span>class <span class="ident">AdHocStage</span></span>
<span>(</span><span>transform, prec=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>An ad-hoc stage of a pandas DataFrame-processing pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code></dt>
<dd>The transformation this stage applies to dataframes.</dd>
<dt><strong><code>prec</code></strong> :&ensp;<code>callable</code>, default <code>None</code></dt>
<dd>A callable that returns a boolean value. Represent a a precondition
used to determine whether this stage can be applied to a given
dataframe. If None is given, set to a function always returning True.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L544-L571" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class AdHocStage(PdPipelineStage):
    &#34;&#34;&#34;An ad-hoc stage of a pandas DataFrame-processing pipeline.

    Parameters
    ----------
    transform : callable
        The transformation this stage applies to dataframes.
    prec : callable, default None
        A callable that returns a boolean value. Represent a a precondition
        used to determine whether this stage can be applied to a given
        dataframe. If None is given, set to a function always returning True.
    &#34;&#34;&#34;

    def __init__(self, transform, prec=None, **kwargs):
        if prec is None:
            prec = _always_true
        self._adhoc_transform = transform
        self._adhoc_prec = prec
        super().__init__(**kwargs)

    def _prec(self, df):
        return self._adhoc_prec(df)

    def _transform(self, df, verbose):
        try:
            return self._adhoc_transform(df, verbose=verbose)
        except TypeError:
            return self._adhoc_transform(df)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></b></code>:
<ul class="hlist">
<li><code><a title="pdpipe.core.PdPipelineStage.AdHocStage" href="#pdpipe.core.PdPipelineStage.AdHocStage">AdHocStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.AggByCols" href="#pdpipe.core.PdPipelineStage.AggByCols">AggByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyByCols" href="#pdpipe.core.PdPipelineStage.ApplyByCols">ApplyByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyToRows" href="#pdpipe.core.PdPipelineStage.ApplyToRows">ApplyToRows</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Bin" href="#pdpipe.core.PdPipelineStage.Bin">Bin</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColByFrameFunc" href="#pdpipe.core.PdPipelineStage.ColByFrameFunc">ColByFrameFunc</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColDrop" href="#pdpipe.core.PdPipelineStage.ColDrop">ColDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColRename" href="#pdpipe.core.PdPipelineStage.ColRename">ColRename</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColReorder" href="#pdpipe.core.PdPipelineStage.ColReorder">ColReorder</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnTransformer" href="#pdpipe.core.PdPipelineStage.ColumnTransformer">ColumnTransformer</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage" href="#pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage">ColumnsBasedPipelineStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropDuplicates" href="#pdpipe.core.PdPipelineStage.DropDuplicates">DropDuplicates</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropNa" href="#pdpipe.core.PdPipelineStage.DropNa">DropNa</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropRareTokens" href="#pdpipe.core.PdPipelineStage.DropRareTokens">DropRareTokens</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByLength" href="#pdpipe.core.PdPipelineStage.DropTokensByLength">DropTokensByLength</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByList" href="#pdpipe.core.PdPipelineStage.DropTokensByList">DropTokensByList</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Encode" href="#pdpipe.core.PdPipelineStage.Encode">Encode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FitOnly" href="#pdpipe.core.PdPipelineStage.FitOnly">FitOnly</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FreqDrop" href="#pdpipe.core.PdPipelineStage.FreqDrop">FreqDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Log" href="#pdpipe.core.PdPipelineStage.Log">Log</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.MapColVals" href="#pdpipe.core.PdPipelineStage.MapColVals">MapColVals</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.OneHotEncode" href="#pdpipe.core.PdPipelineStage.OneHotEncode">OneHotEncode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.PdPipeline" href="#pdpipe.core.PdPipelineStage.PdPipeline">PdPipeline</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RegexReplace" href="#pdpipe.core.PdPipelineStage.RegexReplace">RegexReplace</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RemoveStopwords" href="#pdpipe.core.PdPipelineStage.RemoveStopwords">RemoveStopwords</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RowDrop" href="#pdpipe.core.PdPipelineStage.RowDrop">RowDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Scale" href="#pdpipe.core.PdPipelineStage.Scale">Scale</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Schematize" href="#pdpipe.core.PdPipelineStage.Schematize">Schematize</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.SnowballStem" href="#pdpipe.core.PdPipelineStage.SnowballStem">SnowballStem</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists" href="#pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists">TfidfVectorizeTokenLists</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TokenizeText" href="#pdpipe.core.PdPipelineStage.TokenizeText">TokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.UntokenizeText" href="#pdpipe.core.PdPipelineStage.UntokenizeText">UntokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValDrop" href="#pdpipe.core.PdPipelineStage.ValDrop">ValDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValKeep" href="#pdpipe.core.PdPipelineStage.ValKeep">ValKeep</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.apply" href="#pdpipe.core.PdPipelineStage.apply">apply</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.description" href="#pdpipe.core.PdPipelineStage.description">description</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.fit" href="#pdpipe.core.PdPipelineStage.fit">fit</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.fit_transform" href="#pdpipe.core.PdPipelineStage.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.transform" href="#pdpipe.core.PdPipelineStage.transform">transform</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdpipe.core.ColumnsBasedPipelineStage"><code class="flex name class">
<span>class <span class="ident">ColumnsBasedPipelineStage</span></span>
<span>(</span><span>columns, exclude_columns=None, desc_temp=None, none_columns='error', **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A pipeline stage that operates on a subset of dataframe columns.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>object</code>, <code>iterable</code> or <code>callable</code></dt>
<dd>The label, or an iterable of labels, of columns to use. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>object</code>, <code>iterable</code> or <code>callable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns to exclude, given the
<code>columns</code> parameter. Alternatively, this parameter can be assigned a
callable returning a labels iterable from an input pandas.DataFrame.
See pdpipe.cq. Optional. By default no columns are excluded.</dd>
<dt><strong><code>desc_temp</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>If given, assumed to be a format string, and every appearance of {} in
it is replaced with an appropriate string representation of the columns
parameter, and is used as the pipeline description. Ignored if <code>desc</code>
is provided.</dd>
<dt><strong><code>none_columns</code></strong> :&ensp;<code>iterable</code>, <code>callable</code> or <code>str</code>, default <code>'error'</code></dt>
<dd>Determines how None values supplied to the 'columns' parameter should
be handled. If set to 'error', the default, a ValueError is raised if
None is encountered. If set to 'all', it is interpreted to mean all
columns of input dataframes should be operated on. If an iterable is
provided it is interpreted as the default list of columns to operate on
when <code>columns=None</code>. If a callable is provided, it is interpreted as
the default column qualifier that determines input columns when
<code>columns=None</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additionally supports all constructor parameters of PdPipelineStage.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L395-L537" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ColumnsBasedPipelineStage(PdPipelineStage):
    &#34;&#34;&#34;A pipeline stage that operates on a subset of dataframe columns.

    Parameters
    ---------
    columns : object, iterable or callable
        The label, or an iterable of labels, of columns to use. Alternatively,
        this parameter can be assigned a callable returning an iterable of
        labels from an input pandas.DataFrame. See pdpipe.cq.
    exclude_columns : object, iterable or callable, optional
        The label, or an iterable of labels, of columns to exclude, given the
        `columns` parameter. Alternatively, this parameter can be assigned a
        callable returning a labels iterable from an input pandas.DataFrame.
        See pdpipe.cq. Optional. By default no columns are excluded.
    desc_temp : str, optional
        If given, assumed to be a format string, and every appearance of {} in
        it is replaced with an appropriate string representation of the columns
        parameter, and is used as the pipeline description. Ignored if `desc`
        is provided.
    none_columns : iterable, callable or str, default &#39;error&#39;
        Determines how None values supplied to the &#39;columns&#39; parameter should
        be handled. If set to &#39;error&#39;, the default, a ValueError is raised if
        None is encountered. If set to &#39;all&#39;, it is interpreted to mean all
        columns of input dataframes should be operated on. If an iterable is
        provided it is interpreted as the default list of columns to operate on
        when `columns=None`. If a callable is provided, it is interpreted as
        the default column qualifier that determines input columns when
        `columns=None`.
    **kwargs
        Additionally supports all constructor parameters of PdPipelineStage.
    &#34;&#34;&#34;

    @staticmethod
    def _interpret_columns_param(columns, none_error=False, none_columns=None):
        &#34;&#34;&#34;Interprets the value provided to the columns parameter and returns
        a list version of it - if needed - a string representation of it.
        &#34;&#34;&#34;
        if columns is None:
            if none_error:
                raise ValueError((
                    &#39;None is not a valid argument for the columns parameter of&#39;
                    &#39; this pipeline stage.&#39;))
            return ColumnsBasedPipelineStage._interpret_columns_param(
                columns=none_columns)
        if isinstance(columns, str):
            # always check str first, because it has __iter__
            return [columns], columns
        if callable(columns):
            return columns, columns.__doc__ or &#39;&#39;
        # if it was a single string it was already made a list, and it&#39;s not a
        # callable, so it&#39;s either an iterable of labels... or
        if hasattr(columns, &#39;__iter__&#39;):
            return columns, &#39;, &#39;.join(str(elem) for elem in columns)
        # a single non-string label.
        return [columns], str(columns)

    def __init__(
            self, columns, exclude_columns=None, desc_temp=None,
            none_columns=&#39;error&#39;, **kwargs):
        self._exclude_columns = exclude_columns
        if exclude_columns:
            self._exclude_columns = self._interpret_columns_param(
                exclude_columns)
        self._none_error = False
        self._none_cols = None
        # handle none_columns
        if isinstance(none_columns, str):
            if none_columns == &#39;error&#39;:
                self._none_error = True
            elif none_columns == &#39;all&#39;:
                self._none_cols = AllColumns()
            else:
                raise ValueError((
                    &#34;&#39;error&#39; and &#39;all&#39; are the only valid string arguments&#34;
                    &#34; to the none_columns constructor parameter!&#34;))
        elif hasattr(none_columns, &#39;__iter__&#39;):
            self._none_cols = none_columns
        elif callable(none_columns):
            self._none_cols = none_columns
        else:
            raise ValueError((
                &#34;Valid arguments to the none_columns constructor parameter&#34;
                &#34; are &#39;error&#39;, &#39;all&#39;, an iterable of labels or a callable!&#34;
            ))
        # done handling none_columns
        self._col_arg, self._col_str = self._interpret_columns_param(
            columns, self._none_error, none_columns=self._none_cols)
        if (kwargs.get(&#39;desc&#39;) is None) and desc_temp:
            kwargs[&#39;desc&#39;] = desc_temp.format(self._col_str)
        if kwargs.get(&#39;exmsg&#39;) is None:
            kwargs[&#39;exmsg&#39;] = (
                &#39;Pipeline stage failed because not all columns {} &#39;
                &#39;were found in the input dataframe.&#39;
            ).format(self._col_str)
        super().__init__(**kwargs)

    def _is_fittable(self):
        return is_fittable_column_qualifier(self._col_arg)

    @staticmethod
    def __get_cols_by_arg(col_arg, df, fit=False):
        try:
            if fit:
                # try to treat col_arg as a fittable column qualifier
                return col_arg.fit_transform(df)
            # else, no need to fit, so try to treat _col_arg as a callable
            return col_arg(df)
        except AttributeError:
            # got here cause col_arg has no fit_transform method...
            try:
                # so try and treat it as a callable again
                return col_arg(df)
            except TypeError:
                # calling col_arg 2 lines above failed; its a list of labels
                return col_arg
        except TypeError:
            # calling _col_arg 10 lines above failed; its a list of labels
            return col_arg

    def _get_columns(self, df, fit=False):
        cols = ColumnsBasedPipelineStage.__get_cols_by_arg(
            self._col_arg, df, fit=fit)
        if self._exclude_columns:
            exc_cols = ColumnsBasedPipelineStage.__get_cols_by_arg(
                self._exclude_columns, df, fit=fit)
            return [x for x in cols if x not in exc_cols]
        return cols

    def _prec(self, df):
        return set(self._get_columns(df=df)).issubset(df.columns)

    @abc.abstractmethod
    def _transformation(self, df, verbose, fit):
        raise NotImplementedError((
            &#34;Classes extending ColumnsBasedPipelineStage must implement the &#34;
            &#34;_transformation method!&#34;))

    def _fit_transform(self, df, verbose):
        self.is_fitted = True
        return self._transformation(df, verbose, fit=True)

    def _transform(self, df, verbose):
        return self._transformation(df, verbose, fit=False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pdpipe.basic_stages.ColDrop" href="basic_stages.html#pdpipe.basic_stages.ColDrop">ColDrop</a></li>
<li><a title="pdpipe.basic_stages.ValDrop" href="basic_stages.html#pdpipe.basic_stages.ValDrop">ValDrop</a></li>
<li><a title="pdpipe.basic_stages.ValKeep" href="basic_stages.html#pdpipe.basic_stages.ValKeep">ValKeep</a></li>
<li><a title="pdpipe.basic_stages.RowDrop" href="basic_stages.html#pdpipe.basic_stages.RowDrop">RowDrop</a></li>
<li><a title="pdpipe.basic_stages.DropDuplicates" href="basic_stages.html#pdpipe.basic_stages.DropDuplicates">DropDuplicates</a></li>
<li><a title="pdpipe.col_generation.OneHotEncode" href="col_generation.html#pdpipe.col_generation.OneHotEncode">OneHotEncode</a></li>
<li><a title="pdpipe.col_generation.ColumnTransformer" href="col_generation.html#pdpipe.col_generation.ColumnTransformer">ColumnTransformer</a></li>
<li><a title="pdpipe.col_generation.Log" href="col_generation.html#pdpipe.col_generation.Log">Log</a></li>
<li><a title="pdpipe.sklearn_stages.Encode" href="sklearn_stages.html#pdpipe.sklearn_stages.Encode">Encode</a></li>
<li><a title="pdpipe.sklearn_stages.Scale" href="sklearn_stages.html#pdpipe.sklearn_stages.Scale">Scale</a></li>
<li><a title="pdpipe.nltk_stages.DropRareTokens" href="nltk_stages.html#pdpipe.nltk_stages.DropRareTokens">DropRareTokens</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></b></code>:
<ul class="hlist">
<li><code><a title="pdpipe.core.PdPipelineStage.AdHocStage" href="#pdpipe.core.PdPipelineStage.AdHocStage">AdHocStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.AggByCols" href="#pdpipe.core.PdPipelineStage.AggByCols">AggByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyByCols" href="#pdpipe.core.PdPipelineStage.ApplyByCols">ApplyByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyToRows" href="#pdpipe.core.PdPipelineStage.ApplyToRows">ApplyToRows</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Bin" href="#pdpipe.core.PdPipelineStage.Bin">Bin</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColByFrameFunc" href="#pdpipe.core.PdPipelineStage.ColByFrameFunc">ColByFrameFunc</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColDrop" href="#pdpipe.core.PdPipelineStage.ColDrop">ColDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColRename" href="#pdpipe.core.PdPipelineStage.ColRename">ColRename</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColReorder" href="#pdpipe.core.PdPipelineStage.ColReorder">ColReorder</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnTransformer" href="#pdpipe.core.PdPipelineStage.ColumnTransformer">ColumnTransformer</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage" href="#pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage">ColumnsBasedPipelineStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropDuplicates" href="#pdpipe.core.PdPipelineStage.DropDuplicates">DropDuplicates</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropNa" href="#pdpipe.core.PdPipelineStage.DropNa">DropNa</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropRareTokens" href="#pdpipe.core.PdPipelineStage.DropRareTokens">DropRareTokens</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByLength" href="#pdpipe.core.PdPipelineStage.DropTokensByLength">DropTokensByLength</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByList" href="#pdpipe.core.PdPipelineStage.DropTokensByList">DropTokensByList</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Encode" href="#pdpipe.core.PdPipelineStage.Encode">Encode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FitOnly" href="#pdpipe.core.PdPipelineStage.FitOnly">FitOnly</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FreqDrop" href="#pdpipe.core.PdPipelineStage.FreqDrop">FreqDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Log" href="#pdpipe.core.PdPipelineStage.Log">Log</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.MapColVals" href="#pdpipe.core.PdPipelineStage.MapColVals">MapColVals</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.OneHotEncode" href="#pdpipe.core.PdPipelineStage.OneHotEncode">OneHotEncode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.PdPipeline" href="#pdpipe.core.PdPipelineStage.PdPipeline">PdPipeline</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RegexReplace" href="#pdpipe.core.PdPipelineStage.RegexReplace">RegexReplace</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RemoveStopwords" href="#pdpipe.core.PdPipelineStage.RemoveStopwords">RemoveStopwords</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RowDrop" href="#pdpipe.core.PdPipelineStage.RowDrop">RowDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Scale" href="#pdpipe.core.PdPipelineStage.Scale">Scale</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Schematize" href="#pdpipe.core.PdPipelineStage.Schematize">Schematize</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.SnowballStem" href="#pdpipe.core.PdPipelineStage.SnowballStem">SnowballStem</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists" href="#pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists">TfidfVectorizeTokenLists</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TokenizeText" href="#pdpipe.core.PdPipelineStage.TokenizeText">TokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.UntokenizeText" href="#pdpipe.core.PdPipelineStage.UntokenizeText">UntokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValDrop" href="#pdpipe.core.PdPipelineStage.ValDrop">ValDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValKeep" href="#pdpipe.core.PdPipelineStage.ValKeep">ValKeep</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.apply" href="#pdpipe.core.PdPipelineStage.apply">apply</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.description" href="#pdpipe.core.PdPipelineStage.description">description</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.fit" href="#pdpipe.core.PdPipelineStage.fit">fit</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.fit_transform" href="#pdpipe.core.PdPipelineStage.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.transform" href="#pdpipe.core.PdPipelineStage.transform">transform</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdpipe.core.PdPipeline"><code class="flex name class">
<span>class <span class="ident">PdPipeline</span></span>
<span>(</span><span>stages, transformer_getter=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A pipeline for processing pandas DataFrame objects.</p>
<p>transformer_getter is usefull to avoid applying pipeline stages that are
aimed to filter out items in a big dataset to create a training set for a
machine learning model, for example, but should not be applied on future
individual items to be transformed by the fitted pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stages</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of PdPipelineStage objects making up this pipeline.</dd>
<dt><strong><code>transform_getter</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A callable that can be applied to the fitted pipeline to produce a
sub-pipeline of it which should be used to transform dataframes after
the pipeline has been fitted. If not given, the fitted pipeline is used
entirely.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L574-L780" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PdPipeline(PdPipelineStage, collections.abc.Sequence):
    &#34;&#34;&#34;A pipeline for processing pandas DataFrame objects.

    transformer_getter is usefull to avoid applying pipeline stages that are
    aimed to filter out items in a big dataset to create a training set for a
    machine learning model, for example, but should not be applied on future
    individual items to be transformed by the fitted pipeline.

    Parameters
    ----------
    stages : list
        A list of PdPipelineStage objects making up this pipeline.
    transform_getter : callable, optional
        A callable that can be applied to the fitted pipeline to produce a
        sub-pipeline of it which should be used to transform dataframes after
        the pipeline has been fitted. If not given, the fitted pipeline is used
        entirely.
    &#34;&#34;&#34;

    _DEF_EXC_MSG = &#39;Pipeline precondition failed!&#39;

    def __init__(self, stages, transformer_getter=None, **kwargs):
        self._stages = stages
        self._trans_getter = transformer_getter
        self.is_fitted = False
        super_kwargs = {
            &#39;exraise&#39;: False,
            &#39;exmsg&#39;: PdPipeline._DEF_EXC_MSG,
        }
        super_kwargs.update(**kwargs)
        super().__init__(**super_kwargs)

    # implementing a collections.abc.Sequence abstract method
    def __getitem__(self, index):
        if isinstance(index, slice):
            return PdPipeline(self._stages[index])
        return self._stages[index]

    # implementing a collections.abc.Sequence abstract method
    def __len__(self):
        return len(self._stages)

    def _prec(self, df):
        # PdPipeline overrides apply in a way which makes this moot
        raise NotImplementedError

    def _transform(self, df, verbose):
        # PdPipeline overrides apply in a way which makes this moot
        raise NotImplementedError

    def apply(self, df, exraise=None, verbose=False):
        if self.is_fitted:
            return self.transform(X=df, exraise=exraise, verbose=verbose)
        return self.fit_transform(X=df, exraise=exraise, verbose=verbose)

    def fit_transform(self, X, y=None, exraise=None, verbose=None):
        &#34;&#34;&#34;Fits this pipeline and transforms the input dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to transform and fit this pipeline by.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of composing stages is not
            fulfilled by the input dataframe: If True, a
            pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If not given, or set to None, the default behaviour of
            each stage is used, as determined by its &#39;exraise&#39; constructor
            parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            of each stage is checked but before its application. Otherwise, no
            messages are printed.

        Returns
        -------
        pandas.DataFrame
            The resulting dacaframe.
        &#34;&#34;&#34;
        inter_x = X
        for stage in self._stages:
            inter_x = stage.fit_transform(
                X=inter_x,
                y=None,
                exraise=exraise,
                verbose=verbose,
            )
        self.is_fitted = True
        return inter_x

    def fit(self, X, y=None, exraise=None, verbose=None):
        &#34;&#34;&#34;Fits this pipeline without transforming the input dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to fit this pipeline by.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of composing stages is not
            fulfilled by the input dataframe: If True, a
            pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If not given, or set to None, the default behaviour of
            each stage is used, as determined by its &#39;exraise&#39; constructor
            parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            of each stage is checked but before its application. Otherwise, no
            messages are printed.

        Returns
        -------
        pandas.DataFrame
            The input dataframe, unchanged.
        &#34;&#34;&#34;
        self.fit_transform(
            X=X,
            y=None,
            exraise=exraise,
            verbose=verbose,
        )
        return X

    def transform(self, X, y=None, exraise=None, verbose=None):
        &#34;&#34;&#34;Transforms the given dataframe without fitting this pipeline.

        If any stage in this pipeline is fittable but is not fitted, an
        UnfittedPipelineStageError is raised before transformation starts.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to transform.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of composing stages is not
            fulfilled by the input dataframe: If True, a
            pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If not given, or set to None, the default behaviour of
            each stage is used, as determined by its &#39;exraise&#39; constructor
            parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            of each stage is checked but before its application. Otherwise, no
            messages are printed.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        for stage in self._stages:
            if stage._is_fittable() and not stage.is_fitted:
                raise UnfittedPipelineStageError((
                    &#34;PipelineStage {} in pipeline is fittable but&#34;
                    &#34; unfitted!&#34;).format(stage))
        inter_df = X
        for stage in self._stages:
            inter_df = stage.transform(
                X=inter_df,
                y=None,
                exraise=exraise,
                verbose=verbose,
            )
        return inter_df

    __call__ = apply

    def __add__(self, other):
        if isinstance(other, PdPipeline):
            return PdPipeline([*self._stages, *other._stages])
        if isinstance(other, PdPipelineStage):
            return PdPipeline([*self._stages, other])
        return NotImplemented

    def __str__(self):
        res = &#34;A pdpipe pipeline:\n&#34;
        res += &#39;[ 0]  &#39; + &#34;\n      &#34;.join(
            textwrap.wrap(self._stages[0].description())) + &#39;\n&#39;
        for i, stage in enumerate(self._stages[1:]):
            res += &#39;[{:&gt;2}]  &#39;.format(i + 1) + &#34;\n      &#34;.join(
                textwrap.wrap(stage.description())) + &#39;\n&#39;
        return res

    def get_transformer(self):
        &#34;&#34;&#34;Return the transformer induced by this fitted pipeline.

           This transformer is a `pdpipe` pipeline that transforms input data
           in a way corresponding to this pipline after it has been fitted. By
           default this is the pipeline itself, but the `transform_getter`
           constructor parameter can be used to return a sub-pipeline of the
           fitted pipeline instead, for cases where some stages should only be
           applied when fitting this pipeline to data.

        Returns
        -------
        pdpipe.PdPipeline
            The corresponding transformer pipeline induced by this pipeline.
        &#34;&#34;&#34;
        try:
            return self._trans_getter(self)
        except TypeError:  # pragma: no cover
            return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></li>
<li>abc.ABC</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pdpipe.core.PdPipeline.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, X, y=None, exraise=None, verbose=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Fits this pipeline without transforming the input dataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to fit this pipeline by.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code>-<code>like</code>, optional</dt>
<dd>Targets for supervised learning.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Determines behaviour if the precondition of composing stages is not
fulfilled by the input dataframe: If True, a
pdpipe.FailedPreconditionError is raised. If False, the stage is
skipped. If not given, or set to None, the default behaviour of
each stage is used, as determined by its 'exraise' constructor
parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
of each stage is checked but before its application. Otherwise, no
messages are printed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The input dataframe, unchanged.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L666-L698" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fit(self, X, y=None, exraise=None, verbose=None):
    &#34;&#34;&#34;Fits this pipeline without transforming the input dataframe.

    Parameters
    ----------
    X : pandas.DataFrame
        The dataframe to fit this pipeline by.
    y : array-like, optional
        Targets for supervised learning.
    exraise : bool, default None
        Determines behaviour if the precondition of composing stages is not
        fulfilled by the input dataframe: If True, a
        pdpipe.FailedPreconditionError is raised. If False, the stage is
        skipped. If not given, or set to None, the default behaviour of
        each stage is used, as determined by its &#39;exraise&#39; constructor
        parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        of each stage is checked but before its application. Otherwise, no
        messages are printed.

    Returns
    -------
    pandas.DataFrame
        The input dataframe, unchanged.
    &#34;&#34;&#34;
    self.fit_transform(
        X=X,
        y=None,
        exraise=exraise,
        verbose=verbose,
    )
    return X</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipeline.fit_transform"><code class="name flex">
<span>def <span class="ident">fit_transform</span></span>(<span>self, X, y=None, exraise=None, verbose=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Fits this pipeline and transforms the input dataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to transform and fit this pipeline by.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code>-<code>like</code>, optional</dt>
<dd>Targets for supervised learning.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Determines behaviour if the precondition of composing stages is not
fulfilled by the input dataframe: If True, a
pdpipe.FailedPreconditionError is raised. If False, the stage is
skipped. If not given, or set to None, the default behaviour of
each stage is used, as determined by its 'exraise' constructor
parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
of each stage is checked but before its application. Otherwise, no
messages are printed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The resulting dacaframe.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L629-L664" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fit_transform(self, X, y=None, exraise=None, verbose=None):
    &#34;&#34;&#34;Fits this pipeline and transforms the input dataframe.

    Parameters
    ----------
    X : pandas.DataFrame
        The dataframe to transform and fit this pipeline by.
    y : array-like, optional
        Targets for supervised learning.
    exraise : bool, default None
        Determines behaviour if the precondition of composing stages is not
        fulfilled by the input dataframe: If True, a
        pdpipe.FailedPreconditionError is raised. If False, the stage is
        skipped. If not given, or set to None, the default behaviour of
        each stage is used, as determined by its &#39;exraise&#39; constructor
        parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        of each stage is checked but before its application. Otherwise, no
        messages are printed.

    Returns
    -------
    pandas.DataFrame
        The resulting dacaframe.
    &#34;&#34;&#34;
    inter_x = X
    for stage in self._stages:
        inter_x = stage.fit_transform(
            X=inter_x,
            y=None,
            exraise=exraise,
            verbose=verbose,
        )
    self.is_fitted = True
    return inter_x</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipeline.get_transformer"><code class="name flex">
<span>def <span class="ident">get_transformer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the transformer induced by this fitted pipeline.</p>
<p>This transformer is a <a title="pdpipe" href="index.html"><code>pdpipe</code></a> pipeline that transforms input data
in a way corresponding to this pipline after it has been fitted. By
default this is the pipeline itself, but the <code>transform_getter</code>
constructor parameter can be used to return a sub-pipeline of the
fitted pipeline instead, for cases where some stages should only be
applied when fitting this pipeline to data.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pdpipe.PdPipeline</code></dt>
<dd>The corresponding transformer pipeline induced by this pipeline.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L762-L780" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_transformer(self):
    &#34;&#34;&#34;Return the transformer induced by this fitted pipeline.

       This transformer is a `pdpipe` pipeline that transforms input data
       in a way corresponding to this pipline after it has been fitted. By
       default this is the pipeline itself, but the `transform_getter`
       constructor parameter can be used to return a sub-pipeline of the
       fitted pipeline instead, for cases where some stages should only be
       applied when fitting this pipeline to data.

    Returns
    -------
    pdpipe.PdPipeline
        The corresponding transformer pipeline induced by this pipeline.
    &#34;&#34;&#34;
    try:
        return self._trans_getter(self)
    except TypeError:  # pragma: no cover
        return self</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipeline.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, X, y=None, exraise=None, verbose=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Transforms the given dataframe without fitting this pipeline.</p>
<p>If any stage in this pipeline is fittable but is not fitted, an
UnfittedPipelineStageError is raised before transformation starts.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to transform.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code>-<code>like</code>, optional</dt>
<dd>Targets for supervised learning.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Determines behaviour if the precondition of composing stages is not
fulfilled by the input dataframe: If True, a
pdpipe.FailedPreconditionError is raised. If False, the stage is
skipped. If not given, or set to None, the default behaviour of
each stage is used, as determined by its 'exraise' constructor
parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
of each stage is checked but before its application. Otherwise, no
messages are printed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The resulting dataframe.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L700-L742" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def transform(self, X, y=None, exraise=None, verbose=None):
    &#34;&#34;&#34;Transforms the given dataframe without fitting this pipeline.

    If any stage in this pipeline is fittable but is not fitted, an
    UnfittedPipelineStageError is raised before transformation starts.

    Parameters
    ----------
    X : pandas.DataFrame
        The dataframe to transform.
    y : array-like, optional
        Targets for supervised learning.
    exraise : bool, default None
        Determines behaviour if the precondition of composing stages is not
        fulfilled by the input dataframe: If True, a
        pdpipe.FailedPreconditionError is raised. If False, the stage is
        skipped. If not given, or set to None, the default behaviour of
        each stage is used, as determined by its &#39;exraise&#39; constructor
        parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        of each stage is checked but before its application. Otherwise, no
        messages are printed.

    Returns
    -------
    pandas.DataFrame
        The resulting dataframe.
    &#34;&#34;&#34;
    for stage in self._stages:
        if stage._is_fittable() and not stage.is_fitted:
            raise UnfittedPipelineStageError((
                &#34;PipelineStage {} in pipeline is fittable but&#34;
                &#34; unfitted!&#34;).format(stage))
    inter_df = X
    for stage in self._stages:
        inter_df = stage.transform(
            X=inter_df,
            y=None,
            exraise=exraise,
            verbose=verbose,
        )
    return inter_df</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></b></code>:
<ul class="hlist">
<li><code><a title="pdpipe.core.PdPipelineStage.AdHocStage" href="#pdpipe.core.PdPipelineStage.AdHocStage">AdHocStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.AggByCols" href="#pdpipe.core.PdPipelineStage.AggByCols">AggByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyByCols" href="#pdpipe.core.PdPipelineStage.ApplyByCols">ApplyByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyToRows" href="#pdpipe.core.PdPipelineStage.ApplyToRows">ApplyToRows</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Bin" href="#pdpipe.core.PdPipelineStage.Bin">Bin</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColByFrameFunc" href="#pdpipe.core.PdPipelineStage.ColByFrameFunc">ColByFrameFunc</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColDrop" href="#pdpipe.core.PdPipelineStage.ColDrop">ColDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColRename" href="#pdpipe.core.PdPipelineStage.ColRename">ColRename</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColReorder" href="#pdpipe.core.PdPipelineStage.ColReorder">ColReorder</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnTransformer" href="#pdpipe.core.PdPipelineStage.ColumnTransformer">ColumnTransformer</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage" href="#pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage">ColumnsBasedPipelineStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropDuplicates" href="#pdpipe.core.PdPipelineStage.DropDuplicates">DropDuplicates</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropNa" href="#pdpipe.core.PdPipelineStage.DropNa">DropNa</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropRareTokens" href="#pdpipe.core.PdPipelineStage.DropRareTokens">DropRareTokens</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByLength" href="#pdpipe.core.PdPipelineStage.DropTokensByLength">DropTokensByLength</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByList" href="#pdpipe.core.PdPipelineStage.DropTokensByList">DropTokensByList</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Encode" href="#pdpipe.core.PdPipelineStage.Encode">Encode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FitOnly" href="#pdpipe.core.PdPipelineStage.FitOnly">FitOnly</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FreqDrop" href="#pdpipe.core.PdPipelineStage.FreqDrop">FreqDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Log" href="#pdpipe.core.PdPipelineStage.Log">Log</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.MapColVals" href="#pdpipe.core.PdPipelineStage.MapColVals">MapColVals</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.OneHotEncode" href="#pdpipe.core.PdPipelineStage.OneHotEncode">OneHotEncode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.PdPipeline" href="#pdpipe.core.PdPipelineStage.PdPipeline">PdPipeline</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RegexReplace" href="#pdpipe.core.PdPipelineStage.RegexReplace">RegexReplace</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RemoveStopwords" href="#pdpipe.core.PdPipelineStage.RemoveStopwords">RemoveStopwords</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RowDrop" href="#pdpipe.core.PdPipelineStage.RowDrop">RowDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Scale" href="#pdpipe.core.PdPipelineStage.Scale">Scale</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Schematize" href="#pdpipe.core.PdPipelineStage.Schematize">Schematize</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.SnowballStem" href="#pdpipe.core.PdPipelineStage.SnowballStem">SnowballStem</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists" href="#pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists">TfidfVectorizeTokenLists</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TokenizeText" href="#pdpipe.core.PdPipelineStage.TokenizeText">TokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.UntokenizeText" href="#pdpipe.core.PdPipelineStage.UntokenizeText">UntokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValDrop" href="#pdpipe.core.PdPipelineStage.ValDrop">ValDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValKeep" href="#pdpipe.core.PdPipelineStage.ValKeep">ValKeep</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.apply" href="#pdpipe.core.PdPipelineStage.apply">apply</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.description" href="#pdpipe.core.PdPipelineStage.description">description</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdpipe.core.PdPipelineStage"><code class="flex name class">
<span>class <span class="ident">PdPipelineStage</span></span>
<span>(</span><span>exraise=True, exmsg=None, desc=None, prec=None, skip=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A stage of a pandas DataFrame-processing pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If true, a pdpipe.FailedPreconditionError is raised when this
stage is applied to a dataframe for which the precondition does
not hold. Otherwise the stage is skipped.</dd>
<dt><strong><code>exmsg</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>The message of the exception that is raised on a failed
precondition if exraise is set to True. A default message is used
if None is given.</dd>
<dt><strong><code>desc</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>A short description of this stage, used as its string representation.
A default description is used if None is given.</dd>
<dt><strong><code>prec</code></strong> :&ensp;<code>callable</code>, default <code>None</code></dt>
<dd>This can be assigned a callable that returns boolean values for input
dataframes, which will be used to determine whether input dataframes
satisfy the preconditions for this pipeline stage (see the <code>exraise</code>
parameter for the behaviour of failed preconditions). See pdp.cond for
more information on specialised Condition objects.</dd>
<dt><strong><code>skip</code></strong> :&ensp;<code>callable</code>, default <code>None</code></dt>
<dd>This can be assigned a callable that returns boolean values for input
dataframes, which will be used to determine whether this stage should
be skipped for input dataframes. See pdp.cond for more information on
specialised Condition objects.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L142-L392" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PdPipelineStage(abc.ABC):
    &#34;&#34;&#34;A stage of a pandas DataFrame-processing pipeline.

    Parameters
    ----------
    exraise : bool, default True
        If true, a pdpipe.FailedPreconditionError is raised when this
        stage is applied to a dataframe for which the precondition does
        not hold. Otherwise the stage is skipped.
    exmsg : str, default None
        The message of the exception that is raised on a failed
        precondition if exraise is set to True. A default message is used
        if None is given.
    desc : str, default None
        A short description of this stage, used as its string representation.
        A default description is used if None is given.
    prec : callable, default None
        This can be assigned a callable that returns boolean values for input
        dataframes, which will be used to determine whether input dataframes
        satisfy the preconditions for this pipeline stage (see the `exraise`
        parameter for the behaviour of failed preconditions). See pdp.cond for
        more information on specialised Condition objects.
    skip : callable, default None
        This can be assigned a callable that returns boolean values for input
        dataframes, which will be used to determine whether this stage should
        be skipped for input dataframes. See pdp.cond for more information on
        specialised Condition objects.
    &#34;&#34;&#34;

    _DEF_EXC_MSG = &#39;Precondition failed in stage {}!&#39;
    _DEF_DESCRIPTION = &#39;A pipeline stage.&#39;
    _INIT_KWARGS = [&#39;exraise&#39;, &#39;exmsg&#39;, &#39;desc&#39;]

    def __init__(self, exraise=True, exmsg=None, desc=None, prec=None,
                 skip=None):
        if desc is None:
            desc = PdPipelineStage._DEF_DESCRIPTION
        if exmsg is None:
            exmsg = PdPipelineStage._DEF_EXC_MSG.format(desc)
        self._exraise = exraise
        self._exmsg = exmsg
        self._desc = desc
        self._prec_arg = prec
        self._skip = skip
        self._appmsg = &#39;{}..&#39;.format(desc)
        self.is_fitted = False

    @classmethod
    def _init_kwargs(cls):
        return cls._INIT_KWARGS

    @abc.abstractmethod
    def _prec(self, df):  # pylint: disable=R0201,W0613
        &#34;&#34;&#34;Returns True if this stage can be applied to the given dataframe.&#34;&#34;&#34;
        raise NotImplementedError

    def _compound_prec(self, df):
        if self._prec_arg:
            return self._prec_arg(df)
        return self._prec(df)

    def _fit_transform(self, df, verbose):
        &#34;&#34;&#34;Fits this stage and transforms the input dataframe.&#34;&#34;&#34;
        return self._transform(df, verbose)

    def _is_fittable(self):
        if self.__class__._fit_transform == PdPipelineStage._fit_transform:
            return False
        return True

    @abc.abstractmethod
    def _transform(self, df, verbose):
        &#34;&#34;&#34;Transforms the given dataframe without fitting this stage.&#34;&#34;&#34;
        raise NotImplementedError(&#34;_transform method not implemented!&#34;)

    def apply(self, df, exraise=None, verbose=False):
        &#34;&#34;&#34;Applies this pipeline stage to the given dataframe.

        If the stage is not fitted fit_transform is called. Otherwise,
        transform is called.

        Parameters
        ----------
        df : pandas.DataFrame
            The dataframe to which this pipeline stage will be applied.
        exraise : bool, default None
            Determines behaviour if the precondition of this stage is not
            fulfilled by the given dataframe: If True,
            a pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If None, the default behaviour of this stage is used, as
            determined by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._skip and self._skip(df):
            return df
        if self._compound_prec(df=df):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            if self.is_fitted:
                return self._transform(df, verbose=verbose)
            return self._fit_transform(df, verbose=verbose)
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return df

    __call__ = apply

    def fit_transform(self, X, y=None, exraise=None, verbose=False):
        &#34;&#34;&#34;Fits this stage and transforms the given dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to transform and fit this pipeline stage by.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of this stage is not
            fulfilled by the given dataframe: If True,
            a pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If None, the default behaviour of this stage is used, as
            determined by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._prec(X):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            return self._fit_transform(X, verbose=verbose)
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return X

    def fit(self, X, y=None, exraise=None, verbose=False):
        &#34;&#34;&#34;Fits this stage without transforming the given dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to be transformed.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of this stage is not
            fulfilled by the given dataframe: If True,
            a pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If None, the default behaviour of this stage is used, as
            determined by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._prec(X):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            self._fit_transform(X, verbose=verbose)
            return X
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return X

    def transform(self, X, y=None, exraise=None, verbose=False):
        &#34;&#34;&#34;Transforms the given dataframe without fitting this stage.

        If this stage is fittable but is not fitter, an
        UnfittedPipelineStageError is raised.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to be transformed.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of this stage is not
            fulfilled by the given dataframe: If True,
            a pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If None, the default behaviour of this stage is used, as
            determined by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._prec(X):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            if self._is_fittable():
                if self.is_fitted:
                    return self._transform(X, verbose=verbose)
                raise UnfittedPipelineStageError(
                    &#34;transform of an unfitted pipeline stage was called!&#34;)
            return self._transform(X, verbose=verbose)
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return X

    def __add__(self, other):
        if isinstance(other, PdPipeline):
            return PdPipeline([self, *other._stages])
        if isinstance(other, PdPipelineStage):
            return PdPipeline([self, other])
        return NotImplemented

    def __str__(self):
        return &#34;PdPipelineStage: {}&#34;.format(self._desc)

    def __repr__(self):
        return self.__str__()

    def description(self):
        &#34;&#34;&#34;Returns the description of this pipeline stage&#34;&#34;&#34;
        return self._desc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pdpipe.core.ColumnsBasedPipelineStage" href="#pdpipe.core.ColumnsBasedPipelineStage">ColumnsBasedPipelineStage</a></li>
<li><a title="pdpipe.core.AdHocStage" href="#pdpipe.core.AdHocStage">AdHocStage</a></li>
<li><a title="pdpipe.core.PdPipeline" href="#pdpipe.core.PdPipeline">PdPipeline</a></li>
<li><a title="pdpipe.basic_stages.ColRename" href="basic_stages.html#pdpipe.basic_stages.ColRename">ColRename</a></li>
<li><a title="pdpipe.basic_stages.DropNa" href="basic_stages.html#pdpipe.basic_stages.DropNa">DropNa</a></li>
<li><a title="pdpipe.basic_stages.FreqDrop" href="basic_stages.html#pdpipe.basic_stages.FreqDrop">FreqDrop</a></li>
<li><a title="pdpipe.basic_stages.ColReorder" href="basic_stages.html#pdpipe.basic_stages.ColReorder">ColReorder</a></li>
<li><a title="pdpipe.basic_stages.Schematize" href="basic_stages.html#pdpipe.basic_stages.Schematize">Schematize</a></li>
<li><a title="pdpipe.col_generation.Bin" href="col_generation.html#pdpipe.col_generation.Bin">Bin</a></li>
<li><a title="pdpipe.col_generation.ApplyToRows" href="col_generation.html#pdpipe.col_generation.ApplyToRows">ApplyToRows</a></li>
<li><a title="pdpipe.col_generation.ColByFrameFunc" href="col_generation.html#pdpipe.col_generation.ColByFrameFunc">ColByFrameFunc</a></li>
<li><a title="pdpipe.wrappers.FitOnly" href="wrappers.html#pdpipe.wrappers.FitOnly">FitOnly</a></li>
<li><a title="pdpipe.sklearn_stages.TfidfVectorizeTokenLists" href="sklearn_stages.html#pdpipe.sklearn_stages.TfidfVectorizeTokenLists">TfidfVectorizeTokenLists</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pdpipe.core.PdPipelineStage.AdHocStage"><code class="name flex">
<span>def <span class="ident">AdHocStage</span></span>(<span>self, transform, prec=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds an ad-hoc stage of a pandas DataFrame-processing pipeline to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code></dt>
<dd>The transformation this stage applies to dataframes.</dd>
<dt><strong><code>prec</code></strong> :&ensp;<code>callable</code>, default <code>None</code></dt>
<dd>A callable that returns a boolean value. Represent a a precondition
used to determine whether this stage can be applied to a given
dataframe. If None is given, set to a function always returning True.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.AggByCols"><code class="name flex">
<span>def <span class="ident">AggByCols</span></span>(<span>self, columns, func, result_columns=None, drop=True, func_desc=None, suffix=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage applying a series-wise function to columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code></dt>
<dd>Names of columns on which to apply the given function.</dd>
<dt><strong><code>func</code></strong> :&ensp;<code>function</code></dt>
<dd>The function to be applied to each of the given columns.</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code>, default <code>None</code></dt>
<dd>The names of the new columns resulting from the mapping operation. Must
be of the same length as columns. If None, behavior depends on the
drop parameter: If drop is True, the name of the source column is used;
otherwise, the name of the source column is used with a defined suffix.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being mapped.</dd>
<dt><strong><code>func_desc</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>A function description of the given function; e.g. 'normalizing revenue
by company size'. A default description is used if None is given.</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The suffix to add to resulting columns in case where results_columns
is None and drop is set to False. Of not given, defaults to '_agg'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp; import numpy as np;
&gt;&gt;&gt; data = [[3.2, "acd"], [7.2, "alk"], [12.1, "alk"]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ["ph","lbl"])
&gt;&gt;&gt; log_ph = pdp.ApplyByCols("ph", np.log)
&gt;&gt;&gt; log_ph(df)
         ph  lbl
1  1.163151  acd
2  1.974081  alk
3  2.493205  alk
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ApplyByCols"><code class="name flex">
<span>def <span class="ident">ApplyByCols</span></span>(<span>self, columns, func, result_columns=None, drop=True, func_desc=None, suffix=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage applying an element-wise function to columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code></dt>
<dd>Names of columns on which to apply the given function.</dd>
<dt><strong><code>func</code></strong> :&ensp;<code>function</code></dt>
<dd>The function to be applied to each element of the given columns.</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code>, default <code>None</code></dt>
<dd>The names of the new columns resulting from the mapping operation. Must
be of the same length as columns. If None, behavior depends on the
drop parameter: If drop is True, the name of the source column is used;
otherwise, the name of the source column is used with the suffix
'_app'.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being mapped.</dd>
<dt><strong><code>func_desc</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>A function description of the given function; e.g. 'normalizing revenue
by company size'. Optional.</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>If provided, this string is concated to resulting column labels instead
of '_app'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp; import math;
&gt;&gt;&gt; data = [[3.2, "acd"], [7.2, "alk"], [12.1, "alk"]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ["ph","lbl"])
&gt;&gt;&gt; round_ph = pdp.ApplyByCols("ph", math.ceil)
&gt;&gt;&gt; round_ph(df)
   ph  lbl
1   4  acd
2   8  alk
3  13  alk
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ApplyToRows"><code class="name flex">
<span>def <span class="ident">ApplyToRows</span></span>(<span>self, func, colname=None, follow_column=None, func_desc=None, prec=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage generating columns by applying a function to each row to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>function</code></dt>
<dd>The function to be applied to each row of the processed DataFrame.</dd>
<dt><strong><code>colname</code></strong> :&ensp;<code>single</code> <code>label</code>, default <code>None</code></dt>
<dd>The label of the new column resulting from the function application. If
None, 'new_col' is used. Ignored if a DataFrame is generated by the
function (i.e. each row generates a Series rather than a value), in
which case the laebl of each column in the resulting DataFrame is used.</dd>
<dt><strong><code>follow_column</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>Resulting columns will be inserted after this column. If None, new
columns are inserted at the end of the processed DataFrame.</dd>
<dt><strong><code>func_desc</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>A function description of the given function; e.g. 'normalizing revenue
by company size'. A default description is used if None is given.</dd>
<dt><strong><code>prec</code></strong> :&ensp;<code>function</code>, default <code>None</code></dt>
<dd>A function taking a DataFrame, returning True if it this stage is
applicable to the given DataFrame. If None is given, a function always
returning True is used.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3, 2143], [10, 1321], [7, 1255]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ['years', 'avg_revenue'])
&gt;&gt;&gt; total_rev = lambda row: row['years'] * row['avg_revenue']
&gt;&gt;&gt; add_total_rev = pdp.ApplyToRows(total_rev, 'total_revenue')
&gt;&gt;&gt; add_total_rev(df)
   years  avg_revenue  total_revenue
1      3         2143           6429
2     10         1321          13210
3      7         1255           8785
&gt;&gt;&gt; def halfer(row):
...     new = {'year/2': row['years']/2, 'rev/2': row['avg_revenue']/2}
...     return pd.Series(new)
&gt;&gt;&gt; half_cols = pdp.ApplyToRows(halfer, follow_column='years')
&gt;&gt;&gt; half_cols(df)
   years   rev/2  year/2  avg_revenue
1      3  1071.5     1.5         2143
2     10   660.5     5.0         1321
3      7   627.5     3.5         1255
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.Bin"><code class="name flex">
<span>def <span class="ident">Bin</span></span>(<span>self, bin_map, drop=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that adds a binned version of a column or columns to this pipeline stage.</p>
<p>If drop is set to True the new columns retain the names of the source
columns; otherwise, the resulting column gain the suffix '_bin'</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bin_map</code></strong> :&ensp;<code>dict</code></dt>
<dd>Maps column labels to bin arrays. The bin array is interpreted as
containing start points of consecutive bins, except for the final
point, assumed to be the end point of the last bin. Additionally, a
bin array implicitly projects a left-most bin containing all elements
smaller than the left-most end point and a right-most bin containing
all elements larger that the right-most end point. For example, the
list [0, 5, 8] is interpreted as the bins (-âˆž, 0), [0-5), [5-8) and
[8, âˆž).</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after being binned.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[-3],[4],[5], [9]], [1,2,3, 4], ['speed'])
&gt;&gt;&gt; pdp.Bin({'speed': [5]}, drop=False).apply(df)
   speed speed_bin
1     -3        &lt;5
2      4        &lt;5
3      5        5â‰¤
4      9        5â‰¤
&gt;&gt;&gt; pdp.Bin({'speed': [0,5,8]}, drop=False).apply(df)
   speed speed_bin
1     -3        &lt;0
2      4       0-5
3      5       5-8
4      9        8â‰¤
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ColByFrameFunc"><code class="name flex">
<span>def <span class="ident">ColByFrameFunc</span></span>(<span>self, column, func, follow_column=None, func_desc=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage adding a column by applying a dataframw-wide function to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the resulting column.</dd>
<dt><strong><code>func</code></strong> :&ensp;<code>function</code></dt>
<dd>The function to be applied to the input dataframe. The function should
return a pandas.Series object.</dd>
<dt><strong><code>follow_column</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>Resulting columns will be inserted after this column. If None, new
columns are inserted at the end of the processed DataFrame.</dd>
<dt><strong><code>func_desc</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>A function description of the given function; e.g. 'normalizing revenue
by company size'. A default description is used if None is given.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3, 3], [2, 4], [1, 5]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ["A","B"])
&gt;&gt;&gt; func = lambda df: df['A'] == df['B']
&gt;&gt;&gt; add_equal = pdp.ColByFrameFunc("A==B", func)
&gt;&gt;&gt; add_equal(df)
   A  B   A==B
1  3  3   True
2  2  4  False
3  1  5  False
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ColDrop"><code class="name flex">
<span>def <span class="ident">ColDrop</span></span>(<span>self, columns, errors=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that drops columns by name to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single</code> <code>label</code>, <code>list</code>-<code>like</code> or <code>callable</code></dt>
<dd>The label, or an iterable of labels, of columns to drop. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>object</code>, <code>iterable</code> or <code>callable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns to exclude, given the
<code>columns</code> parameter. Alternatively, this parameter can be assigned a
callable returning a labels iterable from an input pandas.DataFrame.
See pdpipe.cq. Optional. By default no columns are excluded.</dd>
<dt><strong><code>errors</code></strong> :&ensp;{â€˜<code>ignore</code>â€™, â€˜<code>raise</code>â€™}, default â€˜<code>raise</code>â€™</dt>
<dd>If â€˜ignoreâ€™, suppress error and existing labels are dropped.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[8,'a'],[5,'b']], [1,2], ['num', 'char'])
&gt;&gt;&gt; pdp.ColDrop('num').apply(df)
  char
1    a
2    b
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ColRename"><code class="name flex">
<span>def <span class="ident">ColRename</span></span>(<span>self, rename_map, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that renames a column or columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rename_map</code></strong> :&ensp;<code>dict</code></dt>
<dd>Maps old column names to new ones.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[8,'a'],[5,'b']], [1,2], ['num', 'char'])
&gt;&gt;&gt; pdp.ColRename({'num': 'len', 'char': 'initial'}).apply(df)
   len initial
1    8       a
2    5       b
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ColReorder"><code class="name flex">
<span>def <span class="ident">ColReorder</span></span>(<span>self, positions, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that reorders columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>dict</code></dt>
<dd>A mapping of column names to their desired positions after reordering.
Columns not included in the mapping will maintain their relative
positions over the non-mapped colums.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[8,4,3,7]], columns=['a', 'b', 'c', 'd'])
&gt;&gt;&gt; pdp.ColReorder({'b': 0, 'c': 3}).apply(df)
   b  a  d  c
0  4  8  7  3
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ColumnTransformer"><code class="name flex">
<span>def <span class="ident">ColumnTransformer</span></span>(<span>self, columns, result_columns=None, drop=True, suffix=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that applies transformation to dataframe columns to this pipeline stage..</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single</code> <code>label</code>, <code>list</code>-<code>like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be transformed. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq. If None is provided all
input columns are transformed.</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>single</code> <code>label</code> or <code>list</code>-<code>like</code>, default <code>None</code></dt>
<dd>Labels for the new columns resulting from the transformations. Must
be of the same length as columns. If None, behavior depends on the
drop parameter: If drop is True, then the label of the source column is
used; otherwise, the provided 'suffix' is concatenated to the label of
the source column.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being transformed.</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code>, default <code>'_transformed'</code></dt>
<dd>The suffix transformed columns gain if no new column labels are given.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1], [3], [2]], ['UK', 'USSR', 'US'], ['Medal'])
&gt;&gt;&gt; value_map = {1: 'Gold', 2: 'Silver', 3: 'Bronze'}
&gt;&gt;&gt; pdp.MapColVals('Medal', value_map).apply(df)
       Medal
UK      Gold
USSR  Bronze
US    Silver
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage"><code class="name flex">
<span>def <span class="ident">ColumnsBasedPipelineStage</span></span>(<span>self, columns, exclude_columns=None, desc_temp=None, none_columns='error', **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that operates on a subset of dataframe columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>object</code>, <code>iterable</code> or <code>callable</code></dt>
<dd>The label, or an iterable of labels, of columns to use. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>object</code>, <code>iterable</code> or <code>callable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns to exclude, given the
<code>columns</code> parameter. Alternatively, this parameter can be assigned a
callable returning a labels iterable from an input pandas.DataFrame.
See pdpipe.cq. Optional. By default no columns are excluded.</dd>
<dt><strong><code>desc_temp</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>If given, assumed to be a format string, and every appearance of {} in
it is replaced with an appropriate string representation of the columns
parameter, and is used as the pipeline description. Ignored if <code>desc</code>
is provided.</dd>
<dt><strong><code>none_columns</code></strong> :&ensp;<code>iterable</code>, <code>callable</code> or <code>str</code>, default <code>'error'</code></dt>
<dd>Determines how None values supplied to the 'columns' parameter should
be handled. If set to 'error', the default, a ValueError is raised if
None is encountered. If set to 'all', it is interpreted to mean all
columns of input dataframes should be operated on. If an iterable is
provided it is interpreted as the default list of columns to operate on
when <code>columns=None</code>. If a callable is provided, it is interpreted as
the default column qualifier that determines input columns when
<code>columns=None</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additionally supports all constructor parameters of PdPipelineStage.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.DropDuplicates"><code class="name flex">
<span>def <span class="ident">DropDuplicates</span></span>(<span>self, columns=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Drop duplicates in the given columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>column</code> <code>label</code> or <code>sequence</code> of <code>labels</code>, optional</dt>
<dd>The labels of the columns to consider for duplication drop. If not
populated, duplicates are dropped from all columns.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>object</code>, <code>iterable</code> or <code>callable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns to exclude, given the
<code>columns</code> parameter. Alternatively, this parameter can be assigned a
callable returning a labels iterable from an input pandas.DataFrame.
See pdpipe.cq. Optional. By default no columns are excluded.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[8, 1],[8, 2], [9, 2]], [1,2,3], ['a', 'b'])
&gt;&gt;&gt; pdp.DropDuplicates('a').apply(df)
   a  b
1  8  1
3  9  2
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.DropNa"><code class="name flex">
<span>def <span class="ident">DropNa</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that drops null values to this pipeline stage.</p>
<p>Supports all parameter supported by pandas.dropna function.</p>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1,4],[4,None],[1,11]], [1,2,3], ['a','b'])
&gt;&gt;&gt; pdp.DropNa().apply(df)
   a     b
1  1   4.0
3  1  11.0
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.DropRareTokens"><code class="name flex">
<span>def <span class="ident">DropRareTokens</span></span>(<span>self, columns, threshold, drop=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that drop rare tokens from token lists to this pipeline stage.</p>
<p>Target columns must be series of token lists; i.e. every cell in the series
is an iterable of string tokens.</p>
<p>Note: The nltk package must be installed for this pipeline stage to work.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single</code> <code>label</code>, <code>list</code>-<code>like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be transformed. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>threshold</code></strong> :&ensp;<code>int</code></dt>
<dd>The rarity threshold to use. Only tokens appearing more than this
number of times in a column will remain in token lists in that column.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after being transformed,
and the resulting columns retain the names of the source columns.
Otherwise, the new columns gain the suffix '_norare'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[7, ['a', 'a', 'b']], [3, ['b', 'c', 'd']]]
&gt;&gt;&gt; df = pd.DataFrame(data, columns=['num', 'chars'])
&gt;&gt;&gt; rare_dropper = pdp.DropRareTokens('chars', 1)
&gt;&gt;&gt; rare_dropper(df)
   num      chars
0    7  [a, a, b]
1    3        [b]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.DropTokensByLength"><code class="name flex">
<span>def <span class="ident">DropTokensByLength</span></span>(<span>self, columns, min_len, max_len=None, result_columns=None, drop=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage removing tokens by length in string-token list columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code></dt>
<dd>Names of token list columns on which to apply token filtering.</dd>
<dt><strong><code>min_len</code></strong> :&ensp;<code>int</code></dt>
<dd>The minimum length of tokens to keep. Tokens of shorter length are
removed from all token lists.</dd>
<dt><strong><code>max_len</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>The maximum length of tokens to keep. If provided, tokens of longer
length are removed from all token lists.</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code>, default <code>None</code></dt>
<dd>The names of the new columns resulting from the mapping operation.
Must be of the same length as columns. If None, behavior depends on
the drop parameter: If drop is True, the name of the source column
is used; otherwise, the name of the source column is used with the
suffix '_filtered'.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being transformed.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[4, ["a", "bad", "nice"]], [5, ["good", "university"]]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2], ["age","text"])
&gt;&gt;&gt; filter_tokens = pdp.DropTokensByLength('text', 3, 5)
&gt;&gt;&gt; filter_tokens(df)
   age         text
1    4  [bad, nice]
2    5       [good]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.DropTokensByList"><code class="name flex">
<span>def <span class="ident">DropTokensByList</span></span>(<span>self, columns, bad_tokens, result_columns=None, drop=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage removing specific tokens in string-token list columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code></dt>
<dd>Names of token list columns on which to apply token filtering.</dd>
<dt><strong><code>bad_tokens</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>The list of string tokens to remove from all token lists.</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code>, default <code>None</code></dt>
<dd>The names of the new columns resulting from the mapping operation.
Must be of the same length as columns. If None, behavior depends on
the drop parameter: If drop is True, the name of the source column
is used; otherwise, the name of the source column is used with the
suffix '_filtered'.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being transformed.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[4, ["a", "bad", "cat"]], [5, ["bad", "not", "good"]]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2], ["age","text"])
&gt;&gt;&gt; filter_tokens = pdp.DropTokensByList('text', ['bad'])
&gt;&gt;&gt; filter_tokens(df)
   age         text
1    4     [a, cat]
2    5  [not, good]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.Encode"><code class="name flex">
<span>def <span class="ident">Encode</span></span>(<span>self, columns=None, exclude_columns=None, drop=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that encodes categorical columns to integer values to this pipeline stage.</p>
<p>The encoder for each column is saved in the attribute 'encoders', which
is a dict mapping each encoded column name to the
sklearn.preprocessing.LabelEncoder object used to encode it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single</code> <code>label</code>, <code>list</code>-<code>like</code> or <code>callable</code>, default <code>None</code></dt>
<dd>Column labels in the DataFrame to be encoded. If columns is None then
all the columns with object or category dtype will be converted, except
those given in the exclude_columns parameter. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code>, default <code>None</code></dt>
<dd>Label or labels of columns to be excluded from encoding. If None then
no column is excluded. Alternatively, this parameter can be assigned a
callable returning an iterable of labels from an input</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after being encoded,
and the resulting encoded columns retain the names of the source
columns. Otherwise, encoded columns gain the suffix '_enc'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3.2, "acd"], [7.2, "alk"], [12.1, "alk"]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ["ph","lbl"])
&gt;&gt;&gt; encode_stage = pdp.Encode("lbl")
&gt;&gt;&gt; encode_stage(df)
     ph  lbl
1   3.2    0
2   7.2    1
3  12.1    1
&gt;&gt;&gt; encode_stage.encoders["lbl"].inverse_transform([0,1,1])
array(['acd', 'alk', 'alk'], dtype=object)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.FitOnly"><code class="name flex">
<span>def <span class="ident">FitOnly</span></span>(<span>self, stage, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a wrapper that applies a stage to input data only when fitting to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stage</code></strong> :&ensp;<a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage"><code>PdPipelineStage</code></a></dt>
<dd>The pipeline stage to operate on input data only when fitting.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[8,'a'],[5,'b']], [1,2], ['num', 'char'])
&gt;&gt;&gt; stage = pdp.FitOnly(pdp.ColDrop('num'))
&gt;&gt;&gt; stage(df)
  char
1    a
2    b
&gt;&gt;&gt; df2 = pd.DataFrame([[8,'a'],[5,'b']], [1,2], ['num', 'char'])
&gt;&gt;&gt; stage(df2)
   num char
1    8    a
2    5    b
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.FreqDrop"><code class="name flex">
<span>def <span class="ident">FreqDrop</span></span>(<span>self, threshold, column, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that drops rows by value frequency to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>threshold</code></strong> :&ensp;<code>int</code></dt>
<dd>The minimum frequency required for a value to be kept.</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the colum to check for the given value frequency.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1,4],[4,5],[1,11]], [1,2,3], ['a','b'])
&gt;&gt;&gt; pdp.FreqDrop(2, 'a').apply(df)
   a   b
1  1   4
3  1  11
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.Log"><code class="name flex">
<span>def <span class="ident">Log</span></span>(<span>self, columns=None, exclude_columns=None, drop=False, non_neg=False, const_shift=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that log-transforms numeric data to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code>, default <code>None</code></dt>
<dd>Column names in the DataFrame to be encoded. If columns is None then
all the columns with a numeric dtype will be transformed, except those
given in the exclude_columns parameter. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code>, default <code>None</code></dt>
<dd>Label or labels of columns to be excluded from encoding. If None then
no column is excluded. Alternatively, this parameter can be assigned a
callable returning an iterable of labels from an input
pandas.DataFrame. See pdpipe.cq. Optional.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the source columns are dropped after being encoded,
and the resulting encoded columns retain the names of the source
columns. Otherwise, encoded columns gain the suffix '_log'.</dd>
<dt><strong><code>non_neg</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, each transformed column is first shifted by smallest negative
value it includes (non-negative columns are thus not shifted).</dd>
<dt><strong><code>const_shift</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>If given, each transformed column is first shifted by this constant. If
non_neg is True then that transformation is applied first, and only
then is the column shifted by this constant.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3.2, "acd"], [7.2, "alk"], [12.1, "alk"]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ["ph","lbl"])
&gt;&gt;&gt; log_stage = pdp.Log("ph", drop=True)
&gt;&gt;&gt; log_stage(df)
         ph  lbl
1  1.163151  acd
2  1.974081  alk
3  2.493205  alk
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.MapColVals"><code class="name flex">
<span>def <span class="ident">MapColVals</span></span>(<span>self, columns, value_map, result_columns=None, drop=True, suffix=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that replaces the values of a column by a map to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single</code> <code>label</code>, <code>list</code>-<code>like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be mapped. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq. If None is provided all
input columns are mapped.</dd>
<dt><strong><code>value_map</code></strong> :&ensp;<code>dict</code>, <code>function</code> or <code>pandas.Series</code></dt>
<dd>A dictionary mapping existing values to new ones. Values not in the
dictionary as keys will be converted to NaN. If a function is given, it
is applied element-wise to given columns. If a Series is given, values
are mapped by its index to its values.</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>single</code> <code>label</code> or <code>list</code>-<code>like</code>, default <code>None</code></dt>
<dd>Labels for the new columns resulting from the mapping operation. Must
be of the same length as columns. If None, behavior depends on the
drop parameter: If drop is True, then the label of the source column is
used; otherwise, the label of the source column is used with the suffix
'_map'.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being mapped.</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code>, default <code>'_map'</code></dt>
<dd>The suffix mapped columns gain if no new column labels are given.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1], [3], [2]], ['UK', 'USSR', 'US'], ['Medal'])
&gt;&gt;&gt; value_map = {1: 'Gold', 2: 'Silver', 3: 'Bronze'}
&gt;&gt;&gt; pdp.MapColVals('Medal', value_map).apply(df)
       Medal
UK      Gold
USSR  Bronze
US    Silver
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.OneHotEncode"><code class="name flex">
<span>def <span class="ident">OneHotEncode</span></span>(<span>self, columns=None, dummy_na=False, exclude_columns=None, drop_first=True, drop=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that one-hot-encodes categorical columns to this pipeline stage.</p>
<p>By default only k-1 dummies are created fo k categorical levels, as to
avoid perfect multicollinearity between the dummy features (also called
the dummy variabletrap). This is done since features are usually one-hot
encoded for use with linear models, which require this behaviour.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single</code> <code>label</code>, <code>list</code>-<code>like</code> or <code>callable</code>, default <code>None</code></dt>
<dd>Column labels in the DataFrame to be encoded. If columns is None then
all the columns with object or category dtype will be converted, except
those given in the exclude_columns parameter. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>dummy_na</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Add a column to indicate NaNs, if False NaNs are ignored.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code>, default <code>None</code></dt>
<dd>Label or labels of columns to be excluded from encoding. If None then
no column is excluded. Alternatively, this parameter can be assigned a
callable returning an iterable of labels from an input
pandas.DataFrame. See pdpipe.cq. Optional.</dd>
<dt><strong><code>drop_first</code></strong> :&ensp;<code>bool</code> or <code>single</code> <code>label</code>, default <code>True</code></dt>
<dd>Whether to get k-1 dummies out of k categorical levels by removing the
first level. If a non bool argument matching one of the categories is
provided, the dummy column corresponding to this value is dropped
instead of the first level; if it matches no category the first
category will still be dropped.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after being encoded.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([['USA'], ['UK'], ['Greece']], [1,2,3], ['Born'])
&gt;&gt;&gt; pdp.OneHotEncode().apply(df)
   Born_UK  Born_USA
1        0         1
2        1         0
3        0         0
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.PdPipeline"><code class="name flex">
<span>def <span class="ident">PdPipeline</span></span>(<span>self, stages, transformer_getter=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline for processing pandas DataFrame objects to this pipeline stage.</p>
<p>transformer_getter is usefull to avoid applying pipeline stages that are
aimed to filter out items in a big dataset to create a training set for a
machine learning model, for example, but should not be applied on future
individual items to be transformed by the fitted pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stages</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of PdPipelineStage objects making up this pipeline.</dd>
<dt><strong><code>transform_getter</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A callable that can be applied to the fitted pipeline to produce a
sub-pipeline of it which should be used to transform dataframes after
the pipeline has been fitted. If not given, the fitted pipeline is used
entirely.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.RegexReplace"><code class="name flex">
<span>def <span class="ident">RegexReplace</span></span>(<span>self, columns, pattern, replace, result_columns=None, drop=True, func_desc=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage replacing regex occurences in a text column to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code></dt>
<dd>Names of columns on which to apply regex replacement.</dd>
<dt><strong><code>pattern</code></strong> :&ensp;<code>str</code></dt>
<dd>The regex whose occurences will be replaced.</dd>
<dt><strong><code>replace</code></strong> :&ensp;<code>str</code></dt>
<dd>The replacement string to use. This is equivalent to repl in re.sub.</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code>, default <code>None</code></dt>
<dd>The names of the new columns resulting from the mapping operation. Must
be of the same length as columns. If None, behavior depends on the
drop parameter: If drop is True, the name of the source column is used;
otherwise, the name of the source column is used with the suffix
'_reg'.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being transformed.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[4, "more than 12"], [5, "with 5 more"]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2], ["age","text"])
&gt;&gt;&gt; clean_num = pdp.RegexReplace('text', r'\b[0-9]+\b', "NUM")
&gt;&gt;&gt; clean_num(df)
   age           text
1    4  more than NUM
2    5  with NUM more
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.RemoveStopwords"><code class="name flex">
<span>def <span class="ident">RemoveStopwords</span></span>(<span>self, language, columns, drop=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that removes stopwords from a tokenized list to this pipeline stage.</p>
<p>Target columns must be series of token lists; i.e. every cell in the series
is an iterable of string tokens.</p>
<p>Note: The nltk package must be installed for this pipeline stage to work.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>langugae</code></strong> :&ensp;<code>str</code> or <code>array</code>-<code>like</code></dt>
<dd>If a string is given, interpreted as the language of the stopwords, and
should then be one of the languages supported by the NLTK Stopwords
Corpus. If a list is given, it is assumed to be the list of stopwords
to remove.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>single</code> <code>label</code>, <code>list</code>-<code>like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be transformed. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after stopword removal,
and the resulting columns retain the names of the source columns.
Otherwise, resulting columns gain the suffix '_nostop'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt; data = [[3.2, ['kick', 'the', 'baby']]]
&gt;&gt; df = pd.DataFrame(data, [1], ['freq', 'content'])
&gt;&gt; remove_stopwords = pdp.RemoveStopwords('english', 'content')
&gt;&gt; remove_stopwords(df)
   freq       content
1   3.2  [kick, baby]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.RowDrop"><code class="name flex">
<span>def <span class="ident">RowDrop</span></span>(<span>self, conditions, reduce=None, columns=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that drop rows by callable conditions to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>conditions</code></strong> :&ensp;<code>list</code>-<code>like</code> or <code>dict</code></dt>
<dd>The list of conditions that make a row eligible to be dropped. Each
condition must be a callable that take a cell value and return a bool
value. If a list of callables is given, the conditions are checked for
each column value of each row. If a dict mapping column labels to
callables is given, then each condition is only checked for the column
values of the designated column.</dd>
<dt><strong><code>reduce</code></strong> :&ensp;<code>'any'</code>, <code>'all'</code> or <code>'xor'</code>, default <code>'any'</code></dt>
<dd>Determines how row conditions are reduced. If set to 'all', a row must
satisfy all given conditions to be dropped. If set to 'any', rows
satisfying at least one of the conditions are dropped. If set to 'xor',
rows satisfying exactly one of the conditions will be dropped. Set to
'any' by default.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>str</code> or <code>iterable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq. If given,
input conditions will be applied to the sub-dataframe made up of
these columns to determine which rows to drop. Ignored if <code>conditions</code>
is provided with a dict object. If <code>conditions</code> is a list and this
parameter is not provided, all columns are checked (unless
<code>exclude_columns</code> is additionally provided)</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>object</code>, <code>iterable</code> or <code>callable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns to exclude, given the
<code>columns</code> parameter. Alternatively, this parameter can be assigned a
callable returning a labels iterable from an input pandas.DataFrame.
See pdpipe.cq. Optional. By default no columns are excluded.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1,4],[4,5],[5,11]], [1,2,3], ['a','b'])
&gt;&gt;&gt; pdp.RowDrop([lambda x: x &lt; 2]).apply(df)
   a   b
2  4   5
3  5  11
&gt;&gt;&gt; pdp.RowDrop({'a': lambda x: x == 4}).apply(df)
   a   b
1  1   4
3  5  11
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.Scale"><code class="name flex">
<span>def <span class="ident">Scale</span></span>(<span>self, scaler, columns=None, exclude_columns=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that scales data to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>scaler</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of scaler to use to scale the data. One of 'StandardScaler',
'MinMaxScaler', 'MaxAbsScaler', 'RobustScaler', 'QuantileTransformer'
and 'Normalizer'.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>single</code> <code>label</code>, <code>list</code>-<code>like</code> or <code>callable</code>, default <code>None</code></dt>
<dd>Column labels in the DataFrame to be scale. If columns is None then
all columns of numeric dtype will be scaled, except those given in the
exclude_columns parameter. Alternatively, this parameter can be
assigned a callable returning an iterable of labels from an input
pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>str</code> or <code>list</code>-<code>like</code>, optional</dt>
<dd>Label or labels of columns to be excluded from encoding. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>extra</code> <code>keyword</code> <code>arguments</code></dt>
<dd>All valid extra keyword arguments are forwarded to the scaler
constructor on scaler creation (e.g. 'n_quantiles' for
QuantileTransformer). PdPipelineStage valid keyword arguments are used
to override Scale class defaults.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3.2, 0.3], [7.2, 0.35], [12.1, 0.29]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ["ph","gt"])
&gt;&gt;&gt; scale_stage = pdp.Scale("StandardScaler")
&gt;&gt;&gt; scale_stage(df)
         ph        gt
1 -1.181449 -0.508001
2 -0.082427  1.397001
3  1.263876 -0.889001
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.Schematize"><code class="name flex">
<span>def <span class="ident">Schematize</span></span>(<span>self, columns, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Enforces a column schema on input dataframes to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>sequence</code> of <code>labels</code></dt>
<dd>The dataframe schema to enfore on input dataframes.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[2, 4, 8],[3, 6, 9]], [1, 2], ['a', 'b', 'c'])
&gt;&gt;&gt; pdp.Schematize(['a', 'c']).apply(df)
   a  c
1  2  8
2  3  9
&gt;&gt;&gt; pdp.Schematize(['c', 'b']).apply(df)
   c  b
1  8  4
2  9  6
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.SnowballStem"><code class="name flex">
<span>def <span class="ident">SnowballStem</span></span>(<span>self, stemmer_name, columns, drop=True, min_len=None, max_len=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that stems tokens in a list using the Snowball stemmer to this pipeline stage.</p>
<p>Target columns must be series of token lists; i.e. every cell in the series
is an iterable of string tokens.</p>
<p>Note: The nltk package must be installed for this pipeline stage to work.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stemmer_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the Snowball stemmer to use. Should be one of the Snowball
stemmers implemented by nltk. E.g. 'EnglishStemmer'.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>single</code> <code>label</code>, <code>list</code>-<code>like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be transformed. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after stemming, and the
resulting columns retain the names of the source columns. Otherwise,
resulting columns gain the suffix '_stem'.</dd>
<dt><strong><code>min_len</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>If provided, tokens shorter than this length are not stemmed.</dd>
<dt><strong><code>max_len</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>If provided, tokens longer than this length are not stemmed.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3.2, ['kicking', 'boats']]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1], ['freq', 'content'])
&gt;&gt;&gt; remove_stopwords = pdp.SnowballStem('EnglishStemmer', 'content')
&gt;&gt;&gt; remove_stopwords(df)
   freq       content
1   3.2  [kick, boat]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists"><code class="name flex">
<span>def <span class="ident">TfidfVectorizeTokenLists</span></span>(<span>self, column, drop=True, hierarchical_labels=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage TFIDF-vectorizing a token-list column to count columns to this pipeline stage.</p>
<p>Every cell in the input columns is assumed to be a list of strings, each
representing a single token. The resulting TF-IDF vector is exploded into
individual columns, each with the label 'lbl_i' where lbl is the original
column label and i is the index of column in the count vector.</p>
<p>The resulting columns are concatenated to the end of the dataframe.</p>
<p>All valid sklearn.TfidfVectorizer keyword arguemnts can be provided as
keyword arguments to the constructor, except 'input' and 'analyzer', which
will be ignored. As usual, all valid PdPipelineStage constructor parameters
can also be provided as keyword arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>The label of the token-list column to TfIdf-vectorize.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source column is dropped after being transformed.</dd>
<dt><strong><code>hierarchical_labels</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the labels of resulting columns are of the form 'P_F'
where P is the label of the original token-list column and F is the
feature name (i.e. the string token it corresponds to). Otherwise, it
is simply the feature name itself. If you plan to have two different
TfidfVectorizeTokenLists pipeline stages vectorizing two different
token-list columns, you should set this to true, so tf-idf features
originating in different text columns do not overwrite one another.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[2, ['hovercraft', 'eels']], [5, ['eels', 'urethra']]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1, 2], ['Age', 'tokens'])
&gt;&gt;&gt; tfvectorizer = pdp.TfidfVectorizeTokenLists('tokens')
&gt;&gt;&gt; tfvectorizer(df)
   Age      eels  hovercraft   urethra
1    2  0.579739    0.814802  0.000000
2    5  0.579739    0.000000  0.814802
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.TokenizeText"><code class="name flex">
<span>def <span class="ident">TokenizeText</span></span>(<span>self, columns, drop=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that tokenize a text column into token lists to this pipeline stage.</p>
<p>Note: The nltk package must be installed for this pipeline stage to work.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single</code> <code>label</code>, <code>list</code>-<code>like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be transformed. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after being tokenized,
and the resulting tokenized columns retain the names of the source
columns. Otherwise, tokenized columns gain the suffix '_tok'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame(
...     [[3.2, "Kick the baby!"]], [1], ['freq', 'content'])
&gt;&gt;&gt; tokenize_stage = pdp.TokenizeText('content')
&gt;&gt;&gt; tokenize_stage(df)
   freq               content
1   3.2  [Kick, the, baby, !]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.UntokenizeText"><code class="name flex">
<span>def <span class="ident">UntokenizeText</span></span>(<span>self, columns, drop=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that joins token lists to whitespace-seperated strings to this pipeline stage.</p>
<p>Target columns must be series of token lists; i.e. every cell in the series
is an iterable of string tokens.</p>
<p>Note: The nltk package must be installed for this pipeline stage to work.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single</code> <code>label</code>, <code>list</code>-<code>like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be transformed. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after being untokenized,
and the resulting columns retain the names of the source columns.
Otherwise, untokenized columns gain the suffix '_untok'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3.2, ['Shake', 'and', 'bake!']]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1], ['freq', 'content'])
&gt;&gt;&gt; untokenize_stage = pdp.UntokenizeText('content')
&gt;&gt;&gt; untokenize_stage(df)
   freq          content
1   3.2  Shake and bake!
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ValDrop"><code class="name flex">
<span>def <span class="ident">ValDrop</span></span>(<span>self, values, columns=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that drops rows by value to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>values</code></strong> :&ensp;<code>list</code>-<code>like</code></dt>
<dd>A list of the values to drop.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>single</code> <code>label</code>, <code>list</code>-<code>like</code> or <code>callable</code>, default <code>None</code></dt>
<dd>The label, or an iterable of labels, of columns to check for the given
values. Alternatively, this parameter can be assigned a callable
returning an iterable of labels from an input pandas.DataFrame. See
pdpipe.cq. If set to None, all columns are checked.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>object</code>, <code>iterable</code> or <code>callable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns to exclude, given the
<code>columns</code> parameter. Alternatively, this parameter can be assigned a
callable returning a labels iterable from an input pandas.DataFrame.
See pdpipe.cq. Optional. By default no columns are excluded.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1,4],[4,5],[18,11]], [1,2,3], ['a','b'])
&gt;&gt;&gt; pdp.ValDrop([4], 'a').apply(df)
    a   b
1   1   4
3  18  11
&gt;&gt;&gt; pdp.ValDrop([4]).apply(df)
    a   b
3  18  11
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ValKeep"><code class="name flex">
<span>def <span class="ident">ValKeep</span></span>(<span>self, values, columns=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and adds a pipeline stage that keeps rows by value to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>values</code></strong> :&ensp;<code>list</code>-<code>like</code></dt>
<dd>A list of the values to keep.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>single</code> <code>label</code>, <code>list</code>-<code>like</code> or <code>callable</code>, default <code>None</code></dt>
<dd>The label, or an iterable of labels, of columns to check for the given
values. Alternatively, this parameter can be assigned a callable
returning an iterable of labels from an input pandas.DataFrame. See
pdpipe.cq. If set to None, all columns are checked.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>object</code>, <code>iterable</code> or <code>callable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns to exclude, given the
<code>columns</code> parameter. Alternatively, this parameter can be assigned a
callable returning a labels iterable from an input pandas.DataFrame.
See pdpipe.cq. Optional. By default no columns are excluded.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1,4],[4,5],[5,11]], [1,2,3], ['a','b'])
&gt;&gt;&gt; pdp.ValKeep([4, 5], 'a').apply(df)
   a   b
2  4   5
3  5  11
&gt;&gt;&gt; pdp.ValKeep([4, 5]).apply(df)
   a  b
2  4  5
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L117-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, df, exraise=None, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Applies this pipeline stage to the given dataframe.</p>
<p>If the stage is not fitted fit_transform is called. Otherwise,
transform is called.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to which this pipeline stage will be applied.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Determines behaviour if the precondition of this stage is not
fulfilled by the given dataframe: If True,
a pdpipe.FailedPreconditionError is raised. If False, the stage is
skipped. If None, the default behaviour of this stage is used, as
determined by the exraise constructor parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
is checked but before the application of the pipeline stage.
Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The resulting dataframe.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L217-L256" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def apply(self, df, exraise=None, verbose=False):
    &#34;&#34;&#34;Applies this pipeline stage to the given dataframe.

    If the stage is not fitted fit_transform is called. Otherwise,
    transform is called.

    Parameters
    ----------
    df : pandas.DataFrame
        The dataframe to which this pipeline stage will be applied.
    exraise : bool, default None
        Determines behaviour if the precondition of this stage is not
        fulfilled by the given dataframe: If True,
        a pdpipe.FailedPreconditionError is raised. If False, the stage is
        skipped. If None, the default behaviour of this stage is used, as
        determined by the exraise constructor parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        is checked but before the application of the pipeline stage.
        Defaults to False.

    Returns
    -------
    pandas.DataFrame
        The resulting dataframe.
    &#34;&#34;&#34;
    if exraise is None:
        exraise = self._exraise
    if self._skip and self._skip(df):
        return df
    if self._compound_prec(df=df):
        if verbose:
            msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
            print(msg, flush=True)
        if self.is_fitted:
            return self._transform(df, verbose=verbose)
        return self._fit_transform(df, verbose=verbose)
    if exraise:
        raise FailedPreconditionError(self._exmsg)
    return df</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the description of this pipeline stage</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L390-L392" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def description(self):
    &#34;&#34;&#34;Returns the description of this pipeline stage&#34;&#34;&#34;
    return self._desc</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, X, y=None, exraise=None, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Fits this stage without transforming the given dataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to be transformed.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code>-<code>like</code>, optional</dt>
<dd>Targets for supervised learning.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Determines behaviour if the precondition of this stage is not
fulfilled by the given dataframe: If True,
a pdpipe.FailedPreconditionError is raised. If False, the stage is
skipped. If None, the default behaviour of this stage is used, as
determined by the exraise constructor parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
is checked but before the application of the pipeline stage.
Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The resulting dataframe.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L296-L331" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fit(self, X, y=None, exraise=None, verbose=False):
    &#34;&#34;&#34;Fits this stage without transforming the given dataframe.

    Parameters
    ----------
    X : pandas.DataFrame
        The dataframe to be transformed.
    y : array-like, optional
        Targets for supervised learning.
    exraise : bool, default None
        Determines behaviour if the precondition of this stage is not
        fulfilled by the given dataframe: If True,
        a pdpipe.FailedPreconditionError is raised. If False, the stage is
        skipped. If None, the default behaviour of this stage is used, as
        determined by the exraise constructor parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        is checked but before the application of the pipeline stage.
        Defaults to False.

    Returns
    -------
    pandas.DataFrame
        The resulting dataframe.
    &#34;&#34;&#34;
    if exraise is None:
        exraise = self._exraise
    if self._prec(X):
        if verbose:
            msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
            print(msg, flush=True)
        self._fit_transform(X, verbose=verbose)
        return X
    if exraise:
        raise FailedPreconditionError(self._exmsg)
    return X</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.fit_transform"><code class="name flex">
<span>def <span class="ident">fit_transform</span></span>(<span>self, X, y=None, exraise=None, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Fits this stage and transforms the given dataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to transform and fit this pipeline stage by.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code>-<code>like</code>, optional</dt>
<dd>Targets for supervised learning.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Determines behaviour if the precondition of this stage is not
fulfilled by the given dataframe: If True,
a pdpipe.FailedPreconditionError is raised. If False, the stage is
skipped. If None, the default behaviour of this stage is used, as
determined by the exraise constructor parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
is checked but before the application of the pipeline stage.
Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The resulting dataframe.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L260-L294" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fit_transform(self, X, y=None, exraise=None, verbose=False):
    &#34;&#34;&#34;Fits this stage and transforms the given dataframe.

    Parameters
    ----------
    X : pandas.DataFrame
        The dataframe to transform and fit this pipeline stage by.
    y : array-like, optional
        Targets for supervised learning.
    exraise : bool, default None
        Determines behaviour if the precondition of this stage is not
        fulfilled by the given dataframe: If True,
        a pdpipe.FailedPreconditionError is raised. If False, the stage is
        skipped. If None, the default behaviour of this stage is used, as
        determined by the exraise constructor parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        is checked but before the application of the pipeline stage.
        Defaults to False.

    Returns
    -------
    pandas.DataFrame
        The resulting dataframe.
    &#34;&#34;&#34;
    if exraise is None:
        exraise = self._exraise
    if self._prec(X):
        if verbose:
            msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
            print(msg, flush=True)
        return self._fit_transform(X, verbose=verbose)
    if exraise:
        raise FailedPreconditionError(self._exmsg)
    return X</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, X, y=None, exraise=None, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Transforms the given dataframe without fitting this stage.</p>
<p>If this stage is fittable but is not fitter, an
UnfittedPipelineStageError is raised.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to be transformed.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code>-<code>like</code>, optional</dt>
<dd>Targets for supervised learning.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Determines behaviour if the precondition of this stage is not
fulfilled by the given dataframe: If True,
a pdpipe.FailedPreconditionError is raised. If False, the stage is
skipped. If None, the default behaviour of this stage is used, as
determined by the exraise constructor parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
is checked but before the application of the pipeline stage.
Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The resulting dataframe.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/pdpipe/pdpipe/blob/1b9928dba3c713b32ef26eb651142f9b78a9abc5/pdpipe/core.py#L333-L375" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def transform(self, X, y=None, exraise=None, verbose=False):
    &#34;&#34;&#34;Transforms the given dataframe without fitting this stage.

    If this stage is fittable but is not fitter, an
    UnfittedPipelineStageError is raised.

    Parameters
    ----------
    X : pandas.DataFrame
        The dataframe to be transformed.
    y : array-like, optional
        Targets for supervised learning.
    exraise : bool, default None
        Determines behaviour if the precondition of this stage is not
        fulfilled by the given dataframe: If True,
        a pdpipe.FailedPreconditionError is raised. If False, the stage is
        skipped. If None, the default behaviour of this stage is used, as
        determined by the exraise constructor parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        is checked but before the application of the pipeline stage.
        Defaults to False.

    Returns
    -------
    pandas.DataFrame
        The resulting dataframe.
    &#34;&#34;&#34;
    if exraise is None:
        exraise = self._exraise
    if self._prec(X):
        if verbose:
            msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
            print(msg, flush=True)
        if self._is_fittable():
            if self.is_fitted:
                return self._transform(X, verbose=verbose)
            raise UnfittedPipelineStageError(
                &#34;transform of an unfitted pipeline stage was called!&#34;)
        return self._transform(X, verbose=verbose)
    if exraise:
        raise FailedPreconditionError(self._exmsg)
    return X</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdpipe Home" href="https://pdpipe.github.io/pdpipe/">
<img src="https://pdpipe.github.io/pdpipe/logo.png" alt=""> pdpipe
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#creating-pipeline-stages-that-operate-on-column-subsets">Creating pipeline stages that operate on column subsets</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pdpipe" href="index.html">pdpipe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pdpipe.core.make_pdpipeline" href="#pdpipe.core.make_pdpipeline">make_pdpipeline</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pdpipe.core.AdHocStage" href="#pdpipe.core.AdHocStage">AdHocStage</a></code></h4>
</li>
<li>
<h4><code><a title="pdpipe.core.ColumnsBasedPipelineStage" href="#pdpipe.core.ColumnsBasedPipelineStage">ColumnsBasedPipelineStage</a></code></h4>
</li>
<li>
<h4><code><a title="pdpipe.core.PdPipeline" href="#pdpipe.core.PdPipeline">PdPipeline</a></code></h4>
<ul class="">
<li><code><a title="pdpipe.core.PdPipeline.fit" href="#pdpipe.core.PdPipeline.fit">fit</a></code></li>
<li><code><a title="pdpipe.core.PdPipeline.fit_transform" href="#pdpipe.core.PdPipeline.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.core.PdPipeline.get_transformer" href="#pdpipe.core.PdPipeline.get_transformer">get_transformer</a></code></li>
<li><code><a title="pdpipe.core.PdPipeline.transform" href="#pdpipe.core.PdPipeline.transform">transform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></code></h4>
<ul class="">
<li><code><a title="pdpipe.core.PdPipelineStage.AdHocStage" href="#pdpipe.core.PdPipelineStage.AdHocStage">AdHocStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.AggByCols" href="#pdpipe.core.PdPipelineStage.AggByCols">AggByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyByCols" href="#pdpipe.core.PdPipelineStage.ApplyByCols">ApplyByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyToRows" href="#pdpipe.core.PdPipelineStage.ApplyToRows">ApplyToRows</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Bin" href="#pdpipe.core.PdPipelineStage.Bin">Bin</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColByFrameFunc" href="#pdpipe.core.PdPipelineStage.ColByFrameFunc">ColByFrameFunc</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColDrop" href="#pdpipe.core.PdPipelineStage.ColDrop">ColDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColRename" href="#pdpipe.core.PdPipelineStage.ColRename">ColRename</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColReorder" href="#pdpipe.core.PdPipelineStage.ColReorder">ColReorder</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnTransformer" href="#pdpipe.core.PdPipelineStage.ColumnTransformer">ColumnTransformer</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage" href="#pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage">ColumnsBasedPipelineStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropDuplicates" href="#pdpipe.core.PdPipelineStage.DropDuplicates">DropDuplicates</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropNa" href="#pdpipe.core.PdPipelineStage.DropNa">DropNa</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropRareTokens" href="#pdpipe.core.PdPipelineStage.DropRareTokens">DropRareTokens</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByLength" href="#pdpipe.core.PdPipelineStage.DropTokensByLength">DropTokensByLength</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByList" href="#pdpipe.core.PdPipelineStage.DropTokensByList">DropTokensByList</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Encode" href="#pdpipe.core.PdPipelineStage.Encode">Encode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FitOnly" href="#pdpipe.core.PdPipelineStage.FitOnly">FitOnly</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FreqDrop" href="#pdpipe.core.PdPipelineStage.FreqDrop">FreqDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Log" href="#pdpipe.core.PdPipelineStage.Log">Log</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.MapColVals" href="#pdpipe.core.PdPipelineStage.MapColVals">MapColVals</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.OneHotEncode" href="#pdpipe.core.PdPipelineStage.OneHotEncode">OneHotEncode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.PdPipeline" href="#pdpipe.core.PdPipelineStage.PdPipeline">PdPipeline</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RegexReplace" href="#pdpipe.core.PdPipelineStage.RegexReplace">RegexReplace</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RemoveStopwords" href="#pdpipe.core.PdPipelineStage.RemoveStopwords">RemoveStopwords</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RowDrop" href="#pdpipe.core.PdPipelineStage.RowDrop">RowDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Scale" href="#pdpipe.core.PdPipelineStage.Scale">Scale</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Schematize" href="#pdpipe.core.PdPipelineStage.Schematize">Schematize</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.SnowballStem" href="#pdpipe.core.PdPipelineStage.SnowballStem">SnowballStem</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists" href="#pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists">TfidfVectorizeTokenLists</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TokenizeText" href="#pdpipe.core.PdPipelineStage.TokenizeText">TokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.UntokenizeText" href="#pdpipe.core.PdPipelineStage.UntokenizeText">UntokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValDrop" href="#pdpipe.core.PdPipelineStage.ValDrop">ValDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValKeep" href="#pdpipe.core.PdPipelineStage.ValKeep">ValKeep</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.apply" href="#pdpipe.core.PdPipelineStage.apply">apply</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.description" href="#pdpipe.core.PdPipelineStage.description">description</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.fit" href="#pdpipe.core.PdPipelineStage.fit">fit</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.fit_transform" href="#pdpipe.core.PdPipelineStage.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.transform" href="#pdpipe.core.PdPipelineStage.transform">transform</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p><span style="color:#ddd">&#21328;</span></p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>